#+TITLE: Emacs Configuration File
#+AUTHOR: Brandon Sandrowicz
#+EMAIL: brandon@sandrowicz.org
#+TAGS: emacs

* Getting Started
  :PROPERTIES:
  :tangle: no
  :END:

These sections are mostly documentation on how to get things up and running.

** Installation

The following code will bootstrap this configuration if you drop it
into the =~/.emacs.d/init.el= file:

#+begin_src emacs-lisp
(setq dotfiles-dir (file-name-directory
                    (or (buffer-file-name) load-file-name)))

(let* ((org-dir (expand-file-name
                 "lisp" (expand-file-name
                         "org" (expand-file-name
                                "src" dotfiles-dir))))
       (org-contrib-dir (expand-file-name
                         "lisp" (expand-file-name
                                 "contrib" (expand-file-name
                                            ".." org-dir))))
       (load-path (append (list org-dir org-contrib-dir)
                          (or load-path nil))))
  (require 'org-install)
  (require 'ob-tangle))

(org-babel-load-file (expand-file-name "emacs.org" dotfiles-dir))
#+end_src

** Gotchas

This is my section for taking notes on issues that crop up when using
=.org= files to load my Emacs config.

*** Source Blocks While =eval='ing .org files

Source blocks need to be marked as =emacs-lisp=. I've seen some
people's configs marked as =elisp=, but that has caused me a lot of
trouble. For starters, =org-babel-load-file= blows up because it
passes =nil= to =load-file=. This happens because =org-babel-tangle=
seems to require =:tangle on= for blocks that are in languages other
than =emacs-lisp=.

* Emacs Lisp Notes

** RESOURCES:

- http://stackoverflow.com/questions/2234860/lisp-filter-out-results-from-list-not-matching-predicate

** Using variables in alists

Use need to use backtick rather than quote. This allows you to use a
comma to force evaluation of the variable. For example, starting with
this:

#+begin_src emacs-lisp
(setq backup-directory-alist '(("." . "~/.emacs.d/backups")))
#+end_src

One might (naively) end up with this:

#+begin_src emacs-lisp
(setq backup-dir (expand-file-name "backups" dotfiles-dir))
(setq backup-directory-alist '(("." . backup-dir)))
#+end_src

This fails though, because =backup-dir= has not been evaluated. We
need to do something like this:

#+begin_src emacs-lisp
(setq backup-dir (expand-file-name "backups" dotfiles-dir))
(setq backup-directory-alist `(("." . ,backup-dir)))
#+end_src

The backtick quotes the section like the quote did, but it also uses
hints like ',' to evaluate variables.

Source: [[http://stackoverflow.com/questions/1664202/emacs-lisp-evaluate-variable-in-alist][Stack Overflow: Emacs Lisp Evaluate Variable in alist]]

* Initialization
** Customizations

When you use the customization infrastructure to customize variables,
store the changes in this file:

#+begin_src emacs-lisp
(setq custom-file (expand-file-name "custom.el" dotfiles-dir))
#+end_src

** Files and Directories

Create =~/.emacs.d= subdirectories (if they don't exist):

#+begin_src emacs-lisp
(let* ((subdirs '("elisp" "backups" "snippets" "vendor"))
       (fulldirs (mapcar (lambda (d) (expand-file-name d dotfiles-dir)) subdirs)))
  (dolist (dir fulldirs)
    (when (not (file-exists-p dir))
      (message "Make directory: %s" dir)
      (make-directory dir))))
#+end_src

The =~/.emacs.d/vendor= directory is where I put all of my 3rd-party
elisp packages that I don't install from ELPA.

#+begin_src emacs-lisp
(setq vendor-dir (expand-file-name "vendor" dotfiles-dir))
(add-to-list 'load-path vendor-dir)
#+end_src

** Packages

Setup Emacs Lisp Package Archive (ELPA -- part of Emacs 24):

#+begin_src emacs-lisp
(setq package-user-dir (expand-file-name "elpa" dotfiles-dir))

(require 'cl)
(require 'package)

(setq package-archives
      '(("org" . "http://orgmode.org/elpa/")
        ("gnu" . "http://elpa.gnu.org/packages/")
        ("marmalade" . "http://marmalade-repo.org/packages/")
        ("melpa-stable" . "http://melpa-stable.milkbox.net/packages/")))
        ;("melpa" . "http://melpa.org/packages/")))

(package-initialize)

;; Refreshing the package lists is nice, but not so nice when doing
;; lots of edits to your config...
;(package-refresh-contents)

(defun packages-install (packages)
  "Given a list of packages, this will install them from the standard locations."
  (let ((to-install (inverse-filter 'package-installed-p packages)))
    (when to-install
      (package-refresh-contents)
      (dolist (it to-install)
          (package-install it)
      (delete-other-windows)))))
#+end_src

There is also this:

#+begin_src emacs-lisp :tangle no
(defun require-package (package)
  (setq-default highlight-tabs t)
  "Install given PACKAGE."
  (unless (package-installed-p package)
    (unless (assoc package package-archive-contents)
      (package-refresh-contents))
    (package-install package)))
#+end_src

Support function for =packages-install=. Grabbed from [[https://github.com/howardabrams/dot-files/blob/13fe16a2da8ee269de14b2baadd71580e21926f0/emacs-support.org][here]].

#+begin_src emacs-lisp
(defun inverse-filter (condp lst)
  "A filter function, but returns a list of the entries that
don't match the predicate."
  (delq nil
        (mapcar (lambda (x) (and (not (funcall condp x)) x)) lst)))
#+end_src

Packages:

#+begin_src emacs-lisp
(packages-install '(use-package))
(require 'use-package)
#+end_src

#+begin_src emacs-lisp
(packages-install '(vc-darcs
                    ibuffer
                    ibuffer-vc
                    magit
                    ido-vertical-mode
                    projectile
                    flx
                    flx-ido
                    git-commit-mode
                    git-rebase-mode
                    gitconfig-mode
                    gitignore-mode
                    gitattributes-mode))
#+end_src

** Exec Path

The =exec-path= variable doesn't seem to get setup very well. I need
to explicitly add =/usr/local/bin= to it:

#+begin_src emacs-lisp
(defun append-to-exec-path (path)
  "Add PATH to EXEC-PATH"
  (when (and (file-accessible-directory-p path)
             (not (member 'path exec-path)))
    (add-to-list 'exec-path path)))

(append-to-exec-path "/usr/local/bin")
#+end_src

** The =after= Macro

This useful macro allows normalization of elisp to deal with the
absence or presence of =with-eval-after-load= (falling back to the
older =eval-after-load=):

#+begin_src emacs-lisp
(if (fboundp 'with-eval-after-load)
    (defmacro after (feature &rest body)
      "After FEATURE is loaded, evaluate BODY."
      (declare (indent defun))
      `(with-eval-after-load ,feature ,@body))
  (defmacro after (feature &rest body)
    "After FEATURE is loaded, evaluate BODY."
    (declare (indent defun))
    `(eval-after-load ,feature
       '(progn ,@body))))
#+end_src

Sources:
- http://juanjoalvarez.net/es/detail/2014/sep/19/vim-emacsevil-chaotic-migration-guide/
- https://github.com/juanjux/emacs-dotfiles/blob/master/init.el

* Support Functions

** Buffer Global replace-regexp

By default =replace-regexp= only replaces from the current cursor
position to the end of the file. This provides a way to run a replace
on the whole buffer.

#+begin_src emacs-lisp
(defun replace-regexp-g ()
  "Run replace-regexp on the whole buffer"
  (interactive)
  (save-excursion
    (goto-char 0)
    (call-interactively 'replace-regexp)))
#+end_src

** Newline Conversion

Some convenience function to dealing with converting newline types on
a file. I grabbed it from [[https://github.com/redguardtoo/emacs.d/blob/7cbd20004ac7d231274df04165e4b424999165b8/lisp/init-misc.el#L350][here]].

#+begin_src emacs-lisp
(defun dos2unix ()
  "Convert DOS newlines (\r\n) to Unix newlines (\n)"
  (interactive)
  (goto-char (point-min))
  (while (search-forward "\r" nil t) (replace-match "")))

(defun unix2dos ()
  "Convert Unix newlines (\n) to DOS newlines (\r\n)"
  (interactive)
  (goto-char (point-min))
  (while (search-forward "\n" nil t) (replace-match "\r\n")))

#+end_src

** Show ASCII Table

Pull up a buffer for displaying the ASCII table. ([[https://github.com/redguardtoo/emacs.d/blob/7cbd20004ac7d231274df04165e4b424999165b8/lisp/init-misc.el#L362][source]])

#+begin_src emacs-lisp
(defun ascii-table ()
  "Print the ascii table. Based on a defun by Alex Schroeder <asc@bsiag.com>"
  (interactive)
  (switch-to-buffer "*ASCII*")
  (erase-buffer)
  (insert (format "ASCII characters up to number %d.\n" 254))
  (let ((i 0))
    (while (< i 254)
           (setq i (+ i 1))
           (insert (format "%4d %c\n" i i))))
  (beginning-of-buffer))
#+end_src

* General Configuration
** History

Use =savehist-mode= to store the minibuffer history. I picked up
=savehist-mode= from *someone's* Emacs config, but I grabbed the
configuration settings from [[https://github.com/sachac/.emacs.d/blob/gh-pages/Sacha.org#history][here]].

#+begin_src emacs-lisp
(packages-install '(savehist))
(require 'savehist)

(setq savehist-file (expand-file-name "savehist" dotfiles-dir))
(savehist-mode 1)
(setq history-length t)
(setq history-delete-duplicates t)
(setq savehist-save-minibuffer-history t)
(setq savehist-additional-variables '(kill-ring search-ring regexp-search-ring))
(setq savehist-autosave-interval 60)
#+end_src

** Backups

Tell Emacs not to save backup files (those files that end in =~=) in
the current directory. Instead, save them to =~/.emacs.d/backups=.

#+begin_src emacs-lisp
;; Enable backups
(setq backup-dir (expand-file-name "backups" dotfiles-dir))
(setq backup-directory-alist `(("." . ,backup-dir)))
#+end_src

Configure /how/ we save backups:

#+begin_src emacs-lisp
(setq backup-by-copying t) ; don't clobber symlinks
(setq delete-old-versions -1)
(setq version-control t)
(setq vc-make-backup-files t)
(setq auto-save-file-name-transforms '((".*" "~/.emacs.d/auto-save-list/" t)))
(setq kept-new-versions 6)
(setq kept-old-version 2)
(setq version-control t) ; use versioned backups

;;; disable backup / auto-save
;; (setq backup-by-copying t)
;; (setq make-backup-files nil)
;; (setq auto-save-default nil)
#+end_src

** =saveplace=

Remember the last edit position:

#+begin_src emacs-lisp
(packages-install '(saveplace))
(require 'saveplace)
(setq save-place-file (expand-file-name "saveplace" dotfiles-dir))
(setq-default save-place t)
#+end_src

** Line Numbers

*TODO* Limit this to particular modes rather than just enabling it
everywhere.

#+begin_src emacs-lisp
;; Line numbers on the left... globally
(global-linum-mode 1)
#+end_src

** Modify "yes or no" Prompts

I don't want to have to always type out =yes= / =no= to prompted
questions. Let's shorten it to =y= / =n=. We do this by aliasing the
function =yes-or-no-p= (which prompts for the full =yes= / =no=
string) to the function =y-or-n-p= (which only prompts for =y= or
=n=):

#+begin_src emacs-lisp
;; Only prompt for y/n rather than yes/no
(defalias 'yes-or-no-p 'y-or-n-p)
#+end_src
** Ack

Configure =ack-and-a-half=.

#+begin_src emacs-lisp
(require 'ack-and-a-half)

(defalias 'ack 'ack-and-a-half)
(defalias 'ack-same 'ack-and-a-half-same)
(defalias 'ack-find-file 'ack-and-a-half-find-file)
(defalias 'ack-find-file-same 'ack-and-a-half-find-file-same)
(defalias 'ack-with-args 'ack-and-a-half-with-args)
#+end_src

** Scrolling

Sources:
- [[http://www.emacswiki.org/emacs/SmoothScrolling][Emacs Wiki: Smooth Scrolling]]

#+begin_src emacs-lisp
(setq mouse-wheel-scroll-amount '(1 ((shift) . 1))) ; scroll one line at a time
(setq mouse-wheel-progressive-speed nil) ; don't accelerate scrolling
(setq mouse-wheel-follow-mouse 't) ; scroll the window under the mouse
(setq scroll-step 1) ; keyboard scroll one line at a time
#+end_src
** Frames

This allows one to toggle usage of OSX's native full screen
behaviour. Stumbled across this [[http://crypt.codemancers.com/posts/2013-07-05-non-native-fullscreen-for-osx-on-emacs-24-dot-3/][in a blog post]].

#+begin_src emacs-lisp
;; OSX Native Fullscreen
;; =====================
;; Controls behaviour of `toggle-frame-fullscreen` on OSX.
;;
;; This controls whether or not to use the new 'native' fullscreen in
;; OSX that creates a separate workspace for the fullscreen'd
;; app. Setting to false disables use of this.
;;
;; source: http://crypt.codemancers.com/posts/2013-07-05-non-native-fullscreen-for-osx-on-emacs-24-dot-3/
;(setq ns-use-native-fullscreen nil)
#+end_src

Give me the power to maximize the frame dimensions without using
'actual' fullscreen mode (i.e. hiding menus and such). I'm using
[[https://github.com/izawa/maximize/blob/master/maximize.el][maximize.el]] for this.

#+begin_src emacs-lisp
(require 'maximize)

(defun maximize-toggle-frame-max ()
  "Maximize the window (horizontally and vertically).

Note: If one of the dimensions is already maxed, it will be toggled
      off instead of on. Would have to take a deeper look at the
      internals of the functions to check for that or not."
  (interactive)
  (maximize-toggle-frame-vmax)
  (maximize-toggle-frame-hmax))
#+end_src

** Folding
#+begin_src emacs-lisp
(eval-after-load 'hideshow
  '(progn
     (defun evil-za ()
       (interactive)
       (hs-toggle-hiding)
       (hs-hide-level evil-fold-level))

     (defun evil-hs-setup ()
       (define-key evil-normal-state-map "za" 'evil-za)
       (define-key evil-normal-state-map "zm" 'hs-hide-all)
       (define-key evil-normal-state-map "zr" 'hs-show-all)
       (define-key evil-normal-state-map "zo" 'hs-show-block)
       (define-key evil-normal-state-map "zc" 'hs-hide-block))

     (add-hook 'hs-minor-mode-hook 'evil-hs-setup)))

(load-library "hideshow")

(add-hook 'emacs-lisp-mode-hook (lambda () (hs-minor-mode 1)))
(add-hook 'python-mode-hook (lambda () (hs-minor-mode 1)))
(add-hook 'c-mode-hook (lambda () (hs-minor-mode 1)))
#+end_src
** Server

If we aren't running Emacs in the console, then start up the server so
that =emacs-client= works.

#+begin_src emacs-lisp
(require 'warnings)

(when window-system
  (let ((warning-minimum-level :error))
    (server-start)))
#+end_src

* Global Formatting
** Tabs

Configure tabs / indentation:

*TODO* More explanation here.

#+begin_src emacs-lisp
(setq-default indent-tabs-mode nil)
(setq-default tab-width 4) ; or any other preferred value
(setq indent-line-function 'insert-tab)

(defvaralias 'c-basic-offset 'tab-width)
(defvaralias 'cperl-indent-level 'tab-width)
(setq-default py-indent-offset 4)
#+end_src

** Trailing Newline

#+begin_src emacs-lisp
;; Always add a newline at the end of the file
(setq require-final-newline t)
#+end_src

** Encoding

   #+begin_src emacs-lisp
   (set-language-environment "UTF-8")
   (set-terminal-coding-system 'utf-8)
   (set-keyboard-coding-system 'utf-8)
   (prefer-coding-system 'utf-8)
   #+end_src

* Display Settings

  A number of the default settings should just be disabled as they
  tend to get in the way.

  #+begin_src emacs-lisp
  (setq inhibit-startup-message t)
  (setq initial-scratch-message nil)
  (setq visible-bell t)

  ;; Disable the menu if we're on the console.
  (unless (window-system)
    (when (fboundp 'menu-bar-mode)
      (menu-bar-mode -1)))

  ;; When we're in GUI mode, disable toolbars and scrollbars.
  (when (window-system)
    (when (fboundp 'tool-bar-mode)
      (tool-bar-mode -1))

    (when (fboundp 'horizontal-scroll-bar-mode)
      (horizontal-scroll-bar-mode -1))

    (when (fboundp 'scroll-bar-mode)
      (scroll-bar-mode -1)))

  ;; Make sure that everyone reading the window title knows: THIS! IS! EMACS!
  (setq frame-title-format "%b - Emacs")
  (setq icon-title-format "%b - Emacs")

  ;; Don't pull up a GUI-native file selector. Use the minibuffer. Ths
  ;; only way that FSM intended.
  (setq use-file-dialog nil)

  ;; Default to 'truncating' display of long lines rather than
  ;; wrapping them.
  ;(setq-default truncate-lines t)
  #+end_src

  Let's also make the initial window ("frame") a little bigger:

  #+begin_src emacs-lisp
  (add-to-list 'default-frame-alist '(height . 55))
  (add-to-list 'default-frame-alist '(width . 174))
  #+end_src

** Fonts

Set the default font. =ns= is Mac OSX Cocoa / NeXTStep.

#+begin_src emacs-lisp
(when window-system
  (let ((font
         (case window-system
           (ns "Consolas-11") ; MacOSX Cocoa / NeXTStep
           (otherwise "DejaVu Sans Mono-11"))))
    (set-face-attribute 'default nil :font font)))
#+end_src

Old Code:

#+begin_src emacs-lisp :tangle no
;; -!- Old Code -!-
;;
;; (when (eq system-type 'darwin)
;;   ;; default font
;;   (set-face-attribute 'default nil :font "Consolas-11")
;;
;;   ;; use specific font for Korean charset
;;   ;; if you want to use differnt font size for specific charset,
;;   ;; add :size POINT-SIZE in the font-spec
;;   ;(set-fontset-font t 'hangul (font-spec :name "NanumGothicCoding"))
;;   )
#+end_src

** Modeline

#+begin_src emacs-lisp
;; line number in modeline
(line-number-mode 1)

;; column number in modeline
(column-number-mode 1)
#+end_src

** Fic-Mode

=fic-mode= highlights =FIXME=, =TODO=, etc.

#+begin_src emacs-lisp
;; (require 'fic-mode)
;; (add-hook 'c++-mode-hook 'turn-on-fic-mode)
;; (add-hook 'emacs-lisp-mode-hook 'turn-on-fic-mode)
#+end_src

*TODO* Need to work on the appearance of highlighting red-on-yellow
bolded and underlined is a bit garrish.

*Sources:*
- http://www.emacswiki.org/emacs/fic-mode.el
- http://trey-jackson.blogspot.ca/2010/10/emacs-tip-37-fic-modeel.html
** Column Marker Mode

This doesn't work so well. It highlights the character that crosses
the boundary, doesn't show a vertical line indicating where the
boundary is on all lines. (This is what I want.)

#+begin_src emacs-lisp :tangle no
(require 'column-marker)
(add-hook 'emacs-lisp-mode-hook
          (lambda ()
            (interactive)
            (column-marker-1 80)))
#+end_src

** Fill Column Indicator Mode

This does what I want. It displays a line where the fill-column is. As
per the display, it displays a thin line, I personally perfer what
Vim's python-mode does, which is to set the background for the
character position (rectangular block). Maybe I'll configure this
later. Just need to add hooks for the modes where I want this to show
up. Not rocket science... :)

#+begin_src emacs-lisp :tangle no
(require 'fill-column-indicator)
(add-hook 'emacs-lisp-mode-hook 'fci-mode)
#+end_src

** Rainbow Delimiters Mode

=rainbow-delimiters-mode= hightlights delimiter pairs in increasing
depth with different colors. So far I find this useful in Emacs Lisp.

#+begin_src emacs-lisp
(packages-install '(rainbow-delimiters))
(require 'rainbow-delimiters)
(add-hook 'emacs-lisp-mode-hook 'rainbow-delimiters-mode)
#+end_src

** Colors

Install / Configure color themes. :)

#+begin_src emacs-lisp
(packages-install '(solarized-theme
                    base16-theme))

(defun my-add-theme-load-path (path)
  "Add a path to the custom-theme-load-path list."
  (add-to-list 'custom-theme-load-path (file-name-as-directory path)))

(defun my-add-vendor-theme (name)
  "Add a theme path under the vendor/ directory to custom-theme-load-path."
  (my-add-theme-load-path (expand-file-name name vendor-dir)))

(mapc 'my-add-vendor-theme
      '("color-theme-ports"
        "base16-themes"
        "emacs-spacegray-theme"))

;(load-theme 'base16-ocean-dark t)
;(load-theme 'base16-flat-dark t)
(load-theme 'spacegray t)
#+end_src

*Resources:*
- http://batsov.com/articles/2012/02/19/color-theming-in-emacs-reloaded/
- http://stackoverflow.com/questions/9900232/changing-color-themes-emacs-24-order-matters
- http://www.emacswiki.org/emacs/?action=browse;oldid=ColorTheme;id=ColorAndCustomThemes
- https://github.com/sellout/emacs-color-theme-solarized/

* Navigation
** ibuffer-mode

=ibuffer-mode= presents a list of all open buffers in Emacs with an
interface to manage those buffers (remove them, group them, switch to
them, etc). It's somewhat analogous to BufferExplorer in Vim, though I
feel like =ibuffer-mode= has more functionality.

#+begin_src emacs-lisp
  ;; Note: I'm not sure how packages-install and use-package will
  ;; interact. packages-install doesn't do anything if the packages
  ;; are already installed, but if it needs to install them, it also
  ;; loads them IIRC. I'm not sure how use-package will handle that.
  (packages-install '(ibuffer ibuffer-vc))

  (defun my-ibuffer-vc-hook ()
    "Use ibuffer-vc to group by project root."
    (ibuffer-vc-set-filter-groups-by-vc-root)
    (unless (eq ibuffer-sorting-mode 'alphabetic)
      (ibuffer-do-sort-by-alphabetic)))

  (use-package ibuffer
    :commands ibuffer-mode
    :defer 1
    :config (progn
              (require 'ibuffer-vc)
              (add-hook 'ibuffer-hook 'my-ibuffer-vc-hook)))
#+end_src

*TODO*: Implement some non-Version Control based groups. There are
examples [[http://emacs-fu.blogspot.ca/2010/02/dealing-with-many-buffers-ibuffer.html][here]], but they conflict with =ibuffer-vc=. (They are both
vying for control over =ibuffer-saved-filter-groups=).

#+begin_src emacs-lisp :tangle no
  (setq ibuffer-saved-filter-groups '(("default"
                                       ("Org" (mode . org-mode)))))
#+end_src

*TODO*: Look into an interface to switch between grouping methods from
insider of =ibuffer-mode=. I would want there to be a special case for
switching to =ibuffer-vc= generated groups. I would also want to use
=ido-mode= completion for the named grouping methods. =ibuffer-vc=
groups would probably be a good default.

*TODO*: Related to 'switching' interface: Maybe a way to cycle through
all of the saved filter groups.

*notes*:

- Implementing group-switching interface doesn't look too difficult. The choices would
  have to be taken from the 'keys' of the =ibuffer-saved-filter-groups= variable, and
  adding in a manual entry for =ibuffer-vc=. =ibuffer-vc= looks like
  it works by calling =ibuffer-vc-generate-filter-groups-by-vc-root=
  to generate a filter group dynamically. So... we would call
  =ibuffer-switch-to-saved-filter-groups= to swtich to one of the
  saved groups or do something like =(setq ibuffer-filter-groups
  (ibuffer-vc-generate-filter-groups-by-vc-root))= if the user chooses
  =ibuffer-vc= (or just call =ibuffer-vc-set-filter-groups-by-vc-root=
  directly).

Some scratch work:

#+begin_src emacs-lisp :tangle no
(setq ibuffer-saved-filter-groups '(("default"
                                     ("Org" (mode . org-mode)))))

(delq nil (mapcar (lambda (x) (and (eq (car x) "default") x)) ibuffer-saved-filter-groups))


(defun tester (filter-group)
  (interactive (list (ido-completing-read
                      "Filter Group: "
                      (append '("ibuffer-vc")
                              (mapcar 'car ibuffer-saved-filter-groups)))))
  (let ((filter-groups (cond
                        ((eq filter-group "ibuffer-vc") (ibuffer-vc-generate-filter-groups-by-vc-root))
                        (t (cdr (filter
                                 (lambda (x) (eq (car x) filter-group))
                                 'ibuffer-saved-filter-groups))))))
    (message "%s" filter-groups)))
  ;; (cond ((eq filter-group "ibuffer-vc") (ibuffer-vc-set-filter-groups-by-vc-root))
  ;;       (t (ibuffer-switch-to-saved-filter-groups filter-group))))

(tester "blah")
#+end_src

** Ido mode

#+begin_src emacs-lisp
(require 'ido)
(ido-mode t)
#+end_src

I prefer my matches to be shown vertically (like Vim's [[https://github.com/kien/ctrlp.vim][CtrlP]] or
[[https://bitbucket.org/ns9tks/vim-fuzzyfinder/][FuzzyFinder]]). I use =ido-vertical-mode= to do this. It's the 'best'
solution thus far, but I would prefer if cycling through entries in
the match list moved a cursor rather than rotating the list so that
the match is always the one at the top. I may modify this mode, or
write my own to eventually get what I want.

#+begin_src emacs-lisp
;; Display ido-mode matches vertically
(packages-install '(ido-vertical-mode))
(require 'ido-vertical-mode)
(ido-vertical-mode t)
#+end_src

Enable flex matching (via =flx='s =flx-ido=). This is also like CtrlP
and FuzzyFinder. I initially looked into Helm for this, but it seems
like the fuzzy matching is still coming along (currently it only works
in limited instances).

#+begin_src emacs-lisp
(packages-install '(flx-ido))
(require 'flx-ido)
(flx-ido-mode 1)
(setq ido-enable-flex-matching t)
(setq ido-user-faces nil)
#+end_src

Use [[https://github.com/bbatsov/projectile][Projectile]] for in-project searching.

#+begin_src emacs-lisp
(packages-install '(projectile))
(require 'projectile)
(projectile-global-mode)
#+end_src

Let's tie that all together then. If we're in a project, then use
=projectile-find-file=, otherwise we'll use =ido-find-file=. This is
very basic for the time-being, but I'll improve it over time.

#+begin_src emacs-lisp
(defun my-find-file ()
  "Open file using projectile or ido"
  (interactive)
  (if (projectile-project-p)
      (projectile-find-file)
    (ido-find-file)))
#+end_src

** Ido mode Keymaps

Keymaps! I don't like the default =ido-mode= keymaps. I'm used to
using bindings like =C-j= and =C-k= to cycle through the list of
results (using CtrlP in Vim). Vim has programmed me to want =j= and
=k= as up and down movement keys.

#+begin_src emacs-lisp
;; Other Keymap Changes:
;;  C-j ido-select-text          => ido-next-match
;;  C-k ido-delete-file-at-head  => ido-prev-match
;;  C-l ido-reread-directory     => ido-select-text
;;  C-r ido-prev-match           => ido-reread-directory
;;  C-s ido-next-match           => nil

;; TODO Write my own ido-prev-match that deletes to end of input if
;; the cursor is not at the end of the user input (like the
;; delete-file-at-head does).

(define-key ido-file-completion-map "\C-j" 'ido-next-match)
(define-key ido-file-completion-map "\C-k" 'ido-prev-match)
(define-key ido-file-completion-map "\C-l" 'ido-select-text)
(define-key ido-file-completion-map "\C-r" 'ido-reread-directory)
(define-key ido-file-completion-map "\C-s" nil)
#+end_src

Let's get =C-w= working to delete words backwards in =ido-mode=. Well,
at least for file completion as this is my major use of =ido-mode=.

#+begin_src emacs-lisp
;; Fix ido-completion to allow me to use C-w instead of S-M-DEL to
;; delete backward by a word. It's better to use
;; ido-delete-backward-word-updir because it does what I want in this.
;; situation.
;;
(define-key ido-file-completion-map "\C-w" 'ido-delete-backward-word-updir)
#+end_src

* Organization
** Org-Mode

See [[file:org.org][init-org.el]] for details on my [[http://orgmode.org][Org-Mode]] settings.

#+begin_src emacs-lisp
(org-babel-load-file (expand-file-name "org.org" dotfiles-dir))
#+end_src
** Pomodoro

An [[https://github.com/baudtack/pomodoro.el/blob/master/pomodoro.el][Emacs mode]] for using the [[http://pomodorotechnique.com/][Pomodoro technique]].

#+begin_src emacs-lisp
(setq pomodoro-work-time 25)
(setq pomodoro-short-break 5)
(setq pomodoro-long-break 15)
(setq pomodoro-set-number 4)
#+end_src

Defer loading of =pomodoro= until =pomodoro-start= is called.

#+begin_src emacs-lisp
  (use-package pomodoro
    :commands pomodoro-start
    :defer 1
    :config (pomodoro-add-to-mode-line))
#+end_src

*Sources*:
- https://github.com/rodw/.dotfiles/blob/master/emacs/.rods-dot-emacs.org#pomodoro
- http://ivan.kanis.fr/pomodoro.el
- https://github.com/baudtack/pomodoro.el/blob/master/pomodoro.el

* Evil Mode

Make Emacs a little more *evil*...

** Initialize

*NOTE:* =evil-leader= needs to be loaded *before* =evil-mode=.

#+begin_src emacs-lisp
;; Setup evil-leader mode first
(packages-install '(evil-leader))
(require 'evil-leader)
(global-evil-leader-mode)

;; Setup evil-mode >:)
(packages-install '(evil))
(require 'evil)
(evil-mode 1)
#+end_src

** Evil Ex Commands

Emulate Vim's =:sort= command:

#+begin_src emacs-lisp
;; I'm used to using :sort all of the time in Vim, so let's alias
;; :sort to :sort-lines for convenience. Huzzah!
(evil-ex-define-cmd "sort" 'sort-lines)
#+end_src

Emulate Vim's =:set wrap= and =:set nowrap=:

#+begin_src emacs-lisp
;; Quickly enable/disable line wrapping
(evil-ex-define-cmd "wrap" (lambda () (setq truncate-lines nil)))
(evil-ex-define-cmd "nowrap" (lambda () (setq truncate-lines t)))
#+end_src

** Evil Leader Configuration

Set the =<Leader>=:

#+begin_src emacs-lisp
(evil-leader/set-leader ",")
#+end_src

We don't want to lose the functionality of =<,>=
(=evil-repeat-find-char-reverse=). Due to using =<,>= as the =<Leader>=.

#+begin_src emacs-lisp
(evil-leader/set-key "," 'evil-repeat-find-char-reverse)
#+end_src

Create a generic binding for removing trailing whitespace:

#+begin_src emacs-lisp
;; mneumonic: Remove Whitespace
(evil-leader/set-key "rw" 'delete-trailing-whitespace)
#+end_src

My natural tendency for buffer switching is to hit =<,be>= which I have
bound to [[http://www.vim.org/scripts/script.php?script_id=42][BufferExplorer]] in Vim. The functionality of =switch-to-buffer=
isn't the same, but the general idea that I automatically hit =<,be>=
when I want to switch a buffer remains.

That said, =switch-to-buffer= (with =ido-mode=) is probably better
than BufferExplorer, though the ability to see a _complete_ list of
all buffers is missing.

*NOTE*: Using =ibuffer-mode= instead.

#+begin_src emacs-lisp
;(evil-leader/set-key "be" 'switch-to-buffer)
(evil-leader/set-key "be" 'ibuffer)
#+end_src

Other bindings:

*TODO* Break these up with some explanation

#+begin_src emacs-lisp
;; Having a M-x binding that allows for some auto-completion is always
;; good. I can just use evil-ex-mode for the times when I don't care
;; about auto-completion.
(require 'helm-config)
(evil-leader/set-key "xm" 'helm-M-x)

(evil-leader/set-key
  "d" 'dired-jump ; open current dir in dired-mode
  "k" 'ido-kill-buffer ; kill buffer
  "u" 'undo-tree-visualize ; show the undo-tree
  "f" 'ack ; use ack to search through files

  ;; -- eval bindings --
  "ee" 'eval-last-sexp
  "er" 'eval-region
  "ef" 'eval-defun

  ;; -- ace jump mode --
  "jl" 'ace-jump-line-mode
  "jw" 'ace-jump-word-mode
  "jc" 'ace-jump-char-mode)
#+end_src

** Evil Global Keybindings

Bind =C-p= to =my-find-file= so that we can get =CtrlP=-like
functionality, just like in Vim!

#+begin_src emacs-lisp
;; Nothing emulates Vim's CtrlP plugin yet, but binding file-file to
;; C-p will help me with my muscle memory. I may just need to wrap
;; find-file with something that acts more CtrlP-like when I'm in a
;; repository, otherwise it will just do the regular find-file (with
;; ido-mode).
;(define-key evil-normal-state-map "\C-p" 'ido-find-file)
(define-key evil-normal-state-map "\C-p" 'my-find-file)
#+end_src

Vim uses =C-6= to "switch to previous buffer". This allows one to keep
hitting =C-6= to switch back and forth between two
buffers. =evil-mode= doesn't implement this, so we need to implement
this ourselves:

#+begin_src emacs-lisp
;; use C-6 to swap to a previous buffer
(define-key evil-normal-state-map (kbd "C-6") 'evil-buffer)
#+end_src

** The =Escape= Key

Make the =escape= key cancel all the things.

Sources:
- https://github.com/davvil/.emacs.d/blob/64367f2/init.el#L19

#+begin_src emacs-lisp
;;
;; The Escape Key: Make it cancel everything...
;;
(defun minibuffer-keyboard-quit ()
  "Abort recursive edit.
In Delete Selection mode, if the mark is active, just deactivate it;
then it takes a second \\[keyboard-quit] to abort the minibuffer."
  (interactive)
  (if (and delete-selection-mode transient-mark-mode mark-active)
      (setq deactivate-mark  t)
    (when (get-buffer "*Completions*") (delete-windows-on "*Completions*"))
    (abort-recursive-edit)))

(define-key evil-normal-state-map [escape] 'keyboard-quit)
(define-key evil-visual-state-map [escape] 'keyboard-quit)
(define-key minibuffer-local-map [escape] 'minibuffer-keyboard-quit)
(define-key minibuffer-local-ns-map [escape] 'minibuffer-keyboard-quit)
(define-key minibuffer-local-completion-map [escape] 'minibuffer-keyboard-quit)
(define-key minibuffer-local-must-match-map [escape] 'minibuffer-keyboard-quit)
(define-key minibuffer-local-isearch-map [escape] 'minibuffer-keyboard-quit)
#+end_src

** The Minibuffer

Bind =C-w= to =evil-delete-backward-word= in the minibuffer... because
it just makes sense (to me).

#+begin_src emacs-lisp
;;
;; Get C-w in the minibuffer.
;;
(define-key minibuffer-local-map "\C-w" 'evil-delete-backward-word)
(define-key minibuffer-local-ns-map "\C-w" 'evil-delete-backward-word)
(define-key minibuffer-local-completion-map "\C-w" 'evil-delete-backward-word)
(define-key minibuffer-local-must-match-map "\C-w" 'evil-delete-backward-word)
(define-key minibuffer-local-isearch-map "\C-w" 'evil-delete-backward-word)
#+end_src

** =vim-commentary=

#+begin_src emacs-lisp
;; vim-commentary
;; ==============
;; Replace tpope's vim-commentary
;;
;; TODO missing the 'gcu' binding to uncomment a region without a
;; visual selection
;;
(defun evil-comment-dwim ()
  (interactive)
  "Like 'comment-dwim', but switches to Insert state when inserting a comment and not operating on a region."
  (unless (and mark-active transient-mark-mode)
    (unless (evil-insert-state-p)
  (evil-insert-state)))
  (call-interactively #'comment-dwim))
(define-key evil-normal-state-map (kbd "gc") #'evil-comment-dwim)

#+end_src

** =ibuffer-mode=

Configure =evil-mode= and =ibuffer-mode= to work together.

#+begin_src emacs-lisp
(evil-set-initial-state 'ibuffer-mode 'normal)

(eval-after-load 'ibuffer
  '(progn
     ;; use the standard ibuffer bindings as a base
     (set-keymap-parent (evil-get-auxiliary-keymap ibuffer-mode-map 'normal t)
                        (assq-delete-all 'menu-bar (copy-keymap ibuffer-mode-map)))
     (evil-define-key 'normal ibuffer-mode-map "j" 'ibuffer-forward-line)
     (evil-define-key 'normal ibuffer-mode-map "k" 'ibuffer-backward-line)
     (evil-define-key 'normal ibuffer-mode-map "J" 'ibuffer-jump-to-buffer) ; bound to "j" by default
     (evil-define-key 'normal ibuffer-mode-map "/" 'evil-search-forward)
     (evil-define-key 'normal ibuffer-mode-map "n" 'evil-search-next)
     (evil-define-key 'normal ibuffer-mode-map "N" 'evil-search-previous)
     (evil-define-key 'normal ibuffer-mode-map "?" 'evil-search-backward)
   ))
#+end_src

** =org-mode=

Configure =evil-mode= and =org-mode= to work together:

#+begin_src emacs-lisp
;; org-mode Mappings
;; =================
;;
;; Note: I don't like these bindings, but I'll deal with them. My
;; preferred bindings would be:
;;
;;  zo => Open the fold at the current level. All sublevels of folds
;;        retain their state. The body counts as part of the current
;;        fold instead of this weird idea that show-children keeps
;;        the body hidden whole showing immediate sub-headings.
;;
;;  zO => Does what show-subtree does right now. Opens all folds
;;        from the current level downwards.
;;
;;  zC => Works like hide-subtree right now.
;;
;;  zc => Hide at the current level. All sub-levels retain their
;;        state (i.e. if I hit 'zo' to show the fold again, all
;;        sub-levels remember what expanded/collapsed state they are
;;        in.
;;
;; zR => Open all folds (e.g. show-all)
;;
;; zM => Close all folds (e.g. hide-all)
;;
;; zj => Move downwards to the next fold. (downwards in relation to
;;       the file, not the fold level)
;;
;; zk => Move upwards to the next fold. (upwards in relation to the
;;       file, not the fold level)

(evil-leader/set-key-for-mode 'org-mode "le" 'org-insert-link)
(evil-leader/set-key-for-mode 'orgstruct-mode "le" 'org-insert-link)

(evil-define-key 'normal org-mode-map
  (kbd "RET") 'org-open-at-point
  "za"        'org-cycle
  "zA"        'org-shifttab
  "zm"        'hide-body
  "zr"        'show-all
  "zo"        'show-subtree
  "zO"        'show-all
  "zc"        'hide-subtree
  "zC"        'hide-all
  )

(evil-define-key 'normal orgstruct-mode-map
  (kbd "RET") 'org-open-at-point
  "za"        'org-cycle
  "zA"        'org-shifttab
  "zm"        'hide-body
  "zr"        'show-all
  "zo"        'show-subtree
  "zO"        'show-all
  "zc"        'hide-subtree
  "zC"        'hide-all
  )
#+end_src

** Resources

- https://gist.github.com/gcr/3962719
- https://lists.gnu.org/archive/html/emacs-orgmode/2012-02/msg01000.html
- https://github.com/mixandgo/emacs.d/blob/master/my-evil.el
- https://github.com/jubos/dotfiles/blob/master/emacs.d/config/curtis-evil.el
- http://juanjoalvarez.net/es/detail/2014/sep/19/vim-emacsevil-chaotic-migration-guide/

* Coding
** Python

Configure Emacs for editting Python.

- *TODO* Better config
- *TODO* More explanation

#+begin_src emacs-lisp
  ;; http://www.emacswiki.org/emacs/ProgrammingWithPythonModeDotEl
  ;; (add-to-list 'load-path (expand-file-name "python-mode.el-6.2.0" vendor-dir))

  (use-package python-mode
    :mode ("\\.py\\'" . python-mode)
    :interpreter ("python" . python-mode))
#+end_src

** JavaScript

Use =js2-mode= for JavaScript. (Note: I should probably break this up
a bit with some explanation.)

Note:
- I grabbed the bit on =js2-auto-indent-p= from [[https://github.com/mooz/js2-mode/issues/9][here]].

#+begin_src emacs-lisp
  (use-package js2-mode
    :defer 1
    :mode ("\\.js\\'" . js2-mode)
    :pre-load (progn
                (setq-default js2-auto-indent-p t))
    :config
    (progn
      ;; Replace 'function' with 'ƒ'
      (font-lock-add-keywords
       'js2-mode
       `(("\\(function *\\)("
          (0 (progn (compose-region (match-beginning 1) (match-end 1) "ƒ") nil)))))

      ;; Highlight these keywords
      (font-lock-add-keywords
       'js2-mode
       '(("\\<\\(FIX\\|TODO\\|FIXME\\|HACK\\|REFACTOR\\|XXX\\):"
          1 font-lock-warning-face t)))))
#+end_src

Configure indentation controls:

#+begin_src emacs-lisp
  (setq js-basic-indent 2)
  (setq-default js2-basic-indent 2)
  (setq-default js2-basic-offset 2)
  (setq-default js2-enter-indents-newline t)
  (setq-default js2-indent-on-enter-key t)
  ;(setq-default js2-mode-indent-ignore-first-tab t)
#+end_src

Clean up whitespace sometimes:

#+begin_src emacs-lisp
  (setq-default js2-cleanup-whitespace t)
#+end_src

Control over errors:

#+begin_src emacs-lisp

  ;; Let flymake do the error-parsing
  ;;(setq-default js2-show-parse-errors nil)

  (setq-default js2-global-externs
                '("assert" "refute" "setTimeout"
                  "clearTimeout" "setInterval"
                  "clearInterval" "console" "JSON"
                  "jQuery" "$" "angular" "Ember"))

  ;; TODO What does this do:
  (setq js2-mode-toggle-warnings-and-errors t))
#+end_src

* Text Editing
** Markdown

Use =markdown-mode= to edit Markdown files.

#+begin_src emacs-lisp
  (use-package markdown-mode
    :commands markdown-mode
    :mode (("\\.markdown\\'" . markdown-mode)
           ("\\.mkd\\'" . markdown-mode)
           ;("\\.text\\'" . markdown-mode)
           ("\\.md\\'" . markdown-mode)))
#+end_src
* Advanced Stuff
** Edit With Emacs

Edit with Emacs is a Chrome extension that allows you to edit text
from Chrome in Emacs, and then save it back to Chrome. It pairs with a
server to communicate with. In this case, I have setup the elisp
server so that everything is running right in emacs. IIRC, there is
also a Python server implemented that would just call =emacs= or
=emacs-client= and act as a middle-man.

Links:
- [[https://chrome.google.com/webstore/detail/edit-with-emacs/ljobjlafonikaiipfkggjbhkghgicgoh?hl=en][Chrome Store]]
- [[http://www.emacswiki.org/emacs/Edit_with_Emacs][Emacs Wiki]]
- [[https://github.com/stsquad/emacs_chrome][Github]]

Config:
#+begin_src emacs-lisp
  (use-package edit-server
    :init (progn
            ;; Launch the buffer in a new frame, I don't want it to pop
            ;; up in the middle of a frame that I'm already doing
            ;; something in.
            (setq edit-server-new-frame t)
            (edit-server-start)))
#+end_src

** Ace Jump Mode

Load up =ace-jump-mode= for jumping around my buffer. I haven't used
this much yet, but it seems like it could be useful if I ever get
myself into using it more regularly.

#+begin_src emacs-lisp
  (use-package ace-jump-mode
    :commands ace-jump-mode)
#+end_src

The rest of the configuration is in =evil-mode= config right now...

** Animated Welcome Message

An animated welcome message. It's pretty nifty, but it doesn't always
do a good job on startup. Also, I don't know where the =cookie=
function comes from. I wasn't able to find it from the original
source (someone's =.emacs.d= on [[https://github.com][Github]]).

#+begin_src emacs-lisp :tangle no
  ; Animated Welcome Message
  (defconst animate-n-steps 4)
  (defun emacs-reloaded () "animated welcome message" (interactive)
    (animate-string
      (concat ";; Initialization successful, welcome to "
              (substring (emacs-version) 0 16)
              "."
              "\n"
              ; ";; Tip of the Day:\n;;   "
              ; "\n"
              ; (cookie "~/.emacs.d/tip-of-the-day.fortune" "s" "e")
              "\n"
              ";; type C-x C-e for more tips\n"
              "(emacs-reloaded)"
              "\n")
      0 0)
    (end-of-buffer) (newline-and-indent)
    ;; (newline-and-indent)  (newline-and-indent)
  )
  (add-hook 'after-init-hook (lambda ()
                               (maximize-frame)
                               (emacs-reloaded)))
#+end_src

* The *FUTURE*!
** TODO Look into the =use-package= package.
** TODO Look into [[https://github.com/flycheck/flycheck][flycheck]] ([[http://www.emacswiki.org/emacs/Flycheck][emacswiki]]).
Also: [[http://www.flycheck.org/en/latest/guide/languages.html#javascript][How to configure a particular JavaScript backend?]]

** TODO Keep on Pimpin' That Config

Resources:
- [ ] [[https://github.com/rpdillon/emacs-config/blob/master/.gitmodules][rpdillon's emacs config]]
- [ ] [[https://github.com/magnars/.emacs.d/blob/master/setup-js2-mode.el][magnars emacs config]]
- [ ] [[https://github.com/howardabrams/dot-files/tree/13fe16a2da8ee269de14b2baadd71580e21926f0][howard abrams emacs config]]
- [ ] [[https://github.com/zk-phi/phi-grep][phi-grep]]
- [ ] [[http://masteringemacs.org/my-emacs-packages][Mastering Emacs Packages]]

** Literate Programming + Emacs Config

- [[http://sachachua.com/blog/2012/06/literate-programming-emacs-configuration-file/][Sacha Chua: Literate programming and my Emacs configuration file]]
- [[https://github.com/jonnay/emagicians-starter-kit/blob/master/Emagician-Install.org][Emagician Starter Kit]] -- A NiH version of the Emacs Starter Kit.
- [[https://github.com/sachac/.emacs.d/blob/gh-pages/Sacha.org#history][Sacha Chua's Emacs Config]]

** TODO Learn Emacs Lisp

Resources:
- [[https://www.gnu.org/software/emacs/manual/html_mono/eintr.html][An Introduction to Programming in Emacs Lisp]]
- [[http://stackoverflow.com/questions/1664202/emacs-lisp-evaluate-variable-in-alist][Stack Overflow: How to Eval a Variable in an alist]]
- [[http://stackoverflow.com/questions/15485833/emacs-lisp-evaluate-variable-in-alist][Stack Overflow: Emacs lisp evaluate variable in alist]]

** Reading List

- [ ] [[http://www.howardism.org/Technical/Emacs/literate-devops.html][Literate DevOps]]
- [ ] [[http://uncommonlisp.blogspot.ca/2013/01/emacs-vs-vim-part-2.html][Uncommon Lisp]]
- [ ] [[https://news.ycombinator.com/item?id=8709996][Emacs Isn't For Everyone]]

* Misc. Sources

Some sources of config/inspiration that I've tapped in the past:

- https://github.com/drewfrank/dotfiles/blob/master/.emacs
- http://www.emacswiki.org/Evil
- http://changelog.complete.org/archives/661-so-long-vim-im-returning-to-emacs
- http://juanjoalvarez.net/es/detail/2014/sep/19/vim-emacsevil-chaotic-migration-guide/
