#+TITLE: Emacs Configuration File
#+AUTHOR: Brandon Sandrowicz
#+EMAIL: brandon@sandrowicz.org
#+TAGS: emacs

* Getting Started
  :PROPERTIES:
  :tangle: no
  :END:

These sections are mostly documentation on how to get things up and running.

** Installation

The following code will bootstrap this configuration if you drop it
into the =~/.emacs.d/init.el= file:

#+begin_src emacs-lisp
(setq dotfiles-dir (file-name-directory
                    (or (buffer-file-name) load-file-name)))

(let* ((org-dir (expand-file-name
                 "lisp" (expand-file-name
                         "org" (expand-file-name
                                "src" dotfiles-dir))))
       (org-contrib-dir (expand-file-name
                         "lisp" (expand-file-name
                                 "contrib" (expand-file-name
                                            ".." org-dir))))
       (load-path (append (list org-dir org-contrib-dir)
                          (or load-path nil))))
  (require 'org-install)
  (require 'ob-tangle))

(org-babel-load-file (expand-file-name "emacs.org" dotfiles-dir))
#+end_src

** Gotchas

This is my section for taking notes on issues that crop up when using
=.org= files to load my Emacs config.

*** Source Blocks While =eval='ing .org files

Source blocks need to be marked as =emacs-lisp=. I've seen some
people's configs marked as =elisp=, but that has caused me a lot of
trouble. For starters, =org-babel-load-file= blows up because it
passes =nil= to =load-file=. This happens because =org-babel-tangle=
seems to require =:tangle on= for blocks that are in languages other
than =emacs-lisp=.

* Emacs Lisp Notes
** RESOURCES:

- http://stackoverflow.com/questions/2234860/lisp-filter-out-results-from-list-not-matching-predicate

** Using variables in alists

Use need to use backtick rather than quote. This allows you to use a
comma to force evaluation of the variable. For example, starting with
this:

#+begin_src emacs-lisp
(setq backup-directory-alist '(("." . "~/.emacs.d/backups")))
#+end_src

One might (naively) end up with this:

#+begin_src emacs-lisp
(setq backup-dir (expand-file-name "backups" dotfiles-dir))
(setq backup-directory-alist '(("." . backup-dir)))
#+end_src

This fails though, because =backup-dir= has not been evaluated. We
need to do something like this:

#+begin_src emacs-lisp
(setq backup-dir (expand-file-name "backups" dotfiles-dir))
(setq backup-directory-alist `(("." . ,backup-dir)))
#+end_src

The backtick quotes the section like the quote did, but it also uses
hints like ',' to evaluate variables.

Source: [[http://stackoverflow.com/questions/1664202/emacs-lisp-evaluate-variable-in-alist][Stack Overflow: Emacs Lisp Evaluate Variable in alist]]

** "loop for <item> in <list> do <something>"

http://stackoverflow.com/questions/8511583/elisp-loop-over-an-alist
http://wikemacs.org/wiki/Evil#Enter_an_emacs_mode_in_a_given_state

** LET vs LET*
http://stackoverflow.com/questions/554949/let-versus-let-in-common-lisp
** Ternary Operator

=a > b ? a : b= becomes:

#+begin_src emacs-lisp
;(if (> a b) a b)
#+end_src

* Support Code
** Buffer Global replace-regexp

By default =replace-regexp= only replaces from the current cursor
position to the end of the file. This provides a way to run a replace
on the whole buffer.

#+begin_src emacs-lisp
(defun replace-regexp-g ()
  "Run replace-regexp on the whole buffer"
  (interactive)
  (save-excursion
    (goto-char 0)
    (call-interactively 'replace-regexp)))
#+end_src

** Newline Conversion

Some convenience function to dealing with converting newline types on
a file. I grabbed it from [[https://github.com/redguardtoo/emacs.d/blob/7cbd20004ac7d231274df04165e4b424999165b8/lisp/init-misc.el#L350][here]].

#+begin_src emacs-lisp
(defun dos2unix ()
  "Convert DOS newlines (\r\n) to Unix newlines (\n)"
  (interactive)
  (goto-char (point-min))
  (while (search-forward "\r" nil t) (replace-match "")))

(defun unix2dos ()
  "Convert Unix newlines (\n) to DOS newlines (\r\n)"
  (interactive)
  (goto-char (point-min))
  (while (search-forward "\n" nil t) (replace-match "\r\n")))

#+end_src

** Show ASCII Table

Pull up a buffer for displaying the ASCII table. ([[https://github.com/redguardtoo/emacs.d/blob/7cbd20004ac7d231274df04165e4b424999165b8/lisp/init-misc.el#L362][source]])

#+begin_src emacs-lisp
(defun ascii-table ()
  "Print the ascii table. Based on a defun by Alex Schroeder <asc@bsiag.com>"
  (interactive)
  (switch-to-buffer "*ASCII*")
  (erase-buffer)
  (insert (format "ASCII characters up to number %d.\n" 254))
  (let ((i 0))
    (while (< i 254)
           (setq i (+ i 1))
           (insert (format "%4d %c\n" i i))))
  (beginning-of-buffer))
#+end_src

** The =after= Macro

This useful macro allows normalization of elisp to deal with the
absence or presence of =with-eval-after-load= (falling back to the
older =eval-after-load=):

#+begin_src emacs-lisp
(if (fboundp 'with-eval-after-load)
    (defmacro after (feature &rest body)
      "After FEATURE is loaded, evaluate BODY."
      (declare (indent defun))
      `(with-eval-after-load ,feature ,@body))
  (defmacro after (feature &rest body)
    "After FEATURE is loaded, evaluate BODY."
    (declare (indent defun))
    `(eval-after-load ,feature
       '(progn ,@body))))
#+end_src

Example Usage:

#+begin_src emacs-lisp :tangle no
(after 'projectile
  (require-package 'helm-projectile))
#+end_src

Sources:
- http://juanjoalvarez.net/es/detail/2014/sep/19/vim-emacsevil-chaotic-migration-guide/
- https://github.com/juanjux/emacs-dotfiles/blob/master/init.el

** inverse-filter

Reverse of filter. Return all items that don't match =condp=.

 [[https://github.com/howardabrams/dot-files/blob/13fe16a2da8ee269de14b2baadd71580e21926f0/emacs-support.org][source]]

#+begin_src emacs-lisp
(defun inverse-filter (condp lst)
  "A filter function, but returns a list of the entries that
don't match the predicate."
  (delq nil
        (mapcar (lambda (x) (and (not (funcall condp x)) x)) lst)))
#+end_src

** String Functions

From [[http://www.emacswiki.org/emacs/ElispCookbook][EmacsWiki.org]]:

#+begin_src emacs-lisp
  (defun string/starts-with (string prefix)
      "Return t if STRING starts with prefix."
      (and (string-match (rx-to-string `(: bos ,prefix) t)
                         string)
           t))
#+end_src

* Initialization
** Customizations

When you use the customization infrastructure to customize variables,
store the changes in this file:

#+begin_src emacs-lisp
(setq custom-file (expand-file-name "custom.el" dotfiles-dir))
#+end_src

** Files and Directories

Create =~/.emacs.d= subdirectories (if they don't exist):

#+begin_src emacs-lisp
(let* ((subdirs '("elisp" "backups" "snippets" "vendor"))
       (fulldirs (mapcar (lambda (d) (expand-file-name d dotfiles-dir)) subdirs)))
  (dolist (dir fulldirs)
    (when (not (file-exists-p dir))
      (message "Make directory: %s" dir)
      (make-directory dir))))
#+end_src

The =~/.emacs.d/vendor= directory is where I put all of my 3rd-party
elisp packages that I don't install from ELPA.

#+begin_src emacs-lisp
(setq vendor-dir (expand-file-name "vendor" dotfiles-dir))
(add-to-list 'load-path vendor-dir)
#+end_src

** Exec Path

The =exec-path= variable doesn't seem to get setup very well. I need
to explicitly add =/usr/local/bin= to it:

#+begin_src emacs-lisp
  (defun append-to-exec-path (path)
    "Add PATH to EXEC-PATH"
    (when (file-accessible-directory-p path)
      (when (not (member 'path exec-path))
        (add-to-list 'exec-path path))
      (when (not (member 'path (split-string (getenv "PATH") ":")))
        (setenv "PATH" (concat path ":" (getenv "PATH"))))))

  (append-to-exec-path "/usr/local/bin")
#+end_src

** Packages

Setup Emacs Lisp Package Archive (ELPA -- part of Emacs 24):

#+begin_src emacs-lisp
  (setq package-user-dir (expand-file-name "elpa" dotfiles-dir))

  (require 'cl)
  (require 'package)

  (setq package-archives
        '(("org" . "http://orgmode.org/elpa/")
          ("gnu" . "http://elpa.gnu.org/packages/")
          ("marmalade" . "http://marmalade-repo.org/packages/")
          ("melpa-stable" . "http://melpa-stable.milkbox.net/packages/")))
          ;("melpa" . "http://melpa.org/packages/")))

  (package-initialize)

  ;; Refreshing the package lists is nice, but not so nice when doing
  ;; lots of edits to your config...
  ;(package-refresh-contents)
#+end_src

Deprecated:

#+begin_src emacs-lisp
(defun packages-install (packages)
  "Given a list of packages, this will install them from the standard locations."
  (let ((to-install (inverse-filter 'package-installed-p packages)))
    (when to-install
      (package-refresh-contents)
      (dolist (it to-install)
          (package-install it)
      (delete-other-windows)))))
#+end_src

** use-package

The =use-package= package.

#+begin_src emacs-lisp
  (unless (package-installed-p 'use-package)
    (package-install 'use-package))
  (require 'use-package)
#+end_src

#+begin_src emacs-lisp
(packages-install '(vc-darcs
                    magit
                    flx
                    git-commit-mode
                    git-rebase-mode
                    gitconfig-mode
                    gitignore-mode
                    gitattributes-mode))
#+end_src

** Diminish

#+begin_src emacs-lisp
  (use-package diminish
    :commands diminish
    :defer 1)
#+end_src

* General Configuration
** History

Use =savehist-mode= to store the minibuffer history. I picked up
=savehist-mode= from *someone's* Emacs config, but I grabbed the
configuration settings from [[https://github.com/sachac/.emacs.d/blob/gh-pages/Sacha.org#history][here]].

#+begin_src emacs-lisp
  (packages-install '(savehist))
  (use-package savehist
    :init
    (progn
      (setq savehist-file (expand-file-name "savehist" dotfiles-dir))
      (setq history-length t)
      (setq history-delete-duplicates t)
      (setq savehist-save-minibuffer-history t)
      (setq savehist-additional-variables '(kill-ring search-ring regexp-search-ring))
      (setq savehist-autosave-interval 60))
    :config
    (progn
      (savehist-mode 1)))
#+end_src

** Backups

Tell Emacs not to save backup files (those files that end in =~=) in
the current directory. Instead, save them to =~/.emacs.d/backups=.

#+begin_src emacs-lisp
;; Enable backups
(setq backup-dir (expand-file-name "backups" dotfiles-dir))
(setq backup-directory-alist `(("." . ,backup-dir)))
#+end_src

Configure /how/ we save backups:

#+begin_src emacs-lisp
(setq backup-by-copying t) ; don't clobber symlinks
(setq delete-old-versions -1)
(setq version-control t)
(setq vc-make-backup-files t)
(setq auto-save-file-name-transforms '((".*" "~/.emacs.d/auto-save-list/" t)))
(setq kept-new-versions 6)
(setq kept-old-version 2)
(setq version-control t) ; use versioned backups

;;; disable backup / auto-save
;; (setq backup-by-copying t)
;; (setq make-backup-files nil)
;; (setq auto-save-default nil)
#+end_src

** saveplace

Remember the last edit position:

#+begin_src emacs-lisp
  (use-package saveplace
    :ensure saveplace
    :init (setq-default save-place t)
    :config (setq save-place-file (expand-file-name "saveplace" dotfiles-dir)))
#+end_src

** Line Numbers

Turn on line numbers globally.

#+begin_src emacs-lisp
  (use-package linum
    ;; :init
    ;; (progn
    ;;   ;; Line numbers on the left... globally
    ;;   (global-linum-mode 1))
    :config
    (progn
      (add-hook 'prog-mode-hook 'linum-mode)))
#+end_src

** Modify "yes or no" Prompts

I don't want to have to always type out =yes= / =no= to prompted
questions. Let's shorten it to =y= / =n=. We do this by aliasing the
function =yes-or-no-p= (which prompts for the full =yes= / =no=
string) to the function =y-or-n-p= (which only prompts for =y= or
=n=):

#+begin_src emacs-lisp
;; Only prompt for y/n rather than yes/no
(defalias 'yes-or-no-p 'y-or-n-p)
#+end_src

** Ack

Configure =ack-and-a-half=.

#+begin_src emacs-lisp
  (use-package ack-and-a-half
    :config (progn
              (defalias 'ack 'ack-and-a-half)
              (defalias 'ack-same 'ack-and-a-half-same)
              (defalias 'ack-find-file 'ack-and-a-half-find-file)
              (defalias 'ack-find-file-same 'ack-and-a-half-find-file-same)
              (defalias 'ack-with-args 'ack-and-a-half-with-args)))
#+end_src

** Scrolling

Sources:
- [[http://www.emacswiki.org/emacs/SmoothScrolling][Emacs Wiki: Smooth Scrolling]]

#+begin_src emacs-lisp
  (setq mouse-wheel-scroll-amount '(1 ((shift) . 1))) ; scroll one line at a time
  (setq mouse-wheel-progressive-speed nil) ; don't accelerate scrolling
  (setq mouse-wheel-follow-mouse 't) ; scroll the window under the mouse
  (setq scroll-step 1) ; keyboard scroll one line at a time
#+end_src

** Frames

This allows one to toggle usage of OSX's native full screen
behaviour. Stumbled across this [[http://crypt.codemancers.com/posts/2013-07-05-non-native-fullscreen-for-osx-on-emacs-24-dot-3/][in a blog post]].

#+begin_src emacs-lisp
;; OSX Native Fullscreen
;; =====================
;; Controls behaviour of `toggle-frame-fullscreen` on OSX.
;;
;; This controls whether or not to use the new 'native' fullscreen in
;; OSX that creates a separate workspace for the fullscreen'd
;; app. Setting to false disables use of this.
;;
;; source: http://crypt.codemancers.com/posts/2013-07-05-non-native-fullscreen-for-osx-on-emacs-24-dot-3/
;(setq ns-use-native-fullscreen nil)
#+end_src

Give me the power to maximize the frame dimensions without using
'actual' fullscreen mode (i.e. hiding menus and such). I'm using
[[https://github.com/izawa/maximize/blob/master/maximize.el][maximize.el]] for this.

#+begin_src emacs-lisp
  (use-package maximize)

  (defun maximize-toggle-frame-max ()
    "Maximize the window (horizontally and vertically).

  Note: If one of the dimensions is already maxed, it will be toggled
        off instead of on. Would have to take a deeper look at the
        internals of the functions to check for that or not."
    (interactive)
    (maximize-toggle-frame-vmax)
    (maximize-toggle-frame-hmax))
#+end_src

** Folding
#+begin_src emacs-lisp
  (after 'hideshow
    (defun evil-za ()
      (interactive)
      (hs-toggle-hiding)
      (hs-hide-level evil-fold-level))

    (defun evil-hs-setup ()
      (define-key evil-normal-state-map "za" 'evil-za)
      (define-key evil-normal-state-map "zm" 'hs-hide-all)
      (define-key evil-normal-state-map "zr" 'hs-show-all)
      (define-key evil-normal-state-map "zo" 'hs-show-block)
      (define-key evil-normal-state-map "zc" 'hs-hide-block))

    (add-hook 'hs-minor-mode-hook 'evil-hs-setup))

  (use-package hideshow
    :config
    (progn
      (add-hook 'emacs-lisp-mode-hook (lambda () (hs-minor-mode 1)))
      (add-hook 'python-mode-hook (lambda () (hs-minor-mode 1)))
      (add-hook 'c-mode-hook (lambda () (hs-minor-mode 1)))))
#+end_src
** Server

If we aren't running Emacs in the console, then start up the server so
that =emacs-client= works.

#+begin_src emacs-lisp
(require 'warnings)

(when window-system
  (let ((warning-minimum-level :error))
    (server-start)))
#+end_src

** Undo Tree

=undo-tree= mode exposes Emacs' tree-like undo history via a visual
(easy) interface. Yay! =\o/=

#+begin_src emacs-lisp
  (use-package undo-tree
    ;:diminish (undo-tree-mode . " ↺") ; shorten modeline display
    :diminish undo-tree-mode
    :init
    (progn
      (global-undo-tree-mode)
      (setq undo-tree-visualizer-timestamps t)
      (setq undo-tree-visualizer-diff t)))
#+end_src

* Global Formatting
** Tabs

Configure handling of =<Tab>= and indentation.

This controls the use of literal =<Tab>= (=\t=) for indentation. When
set to false, it will insert =tab-width= spaces in place of =\t=.

#+begin_src emacs-lisp
(setq-default indent-tabs-mode nil)
#+end_src

Controls how many spaces are considered a =\t=. This controls how
literal =\t='s are display (I /think/) and how many spaces to insert
when =indent-tabs-mode= is false.

#+begin_src emacs-lisp
(setq-default tab-width 4)
#+end_src

Many modes bind the =<Tab>= key to this function. Let's just run
=insert-tab= instead.

#+begin_src emacs-lisp
(setq indent-line-function 'insert-tab)
#+end_src

It's recommended to set the =c-basic-offset= and =cperl-indent-level=
values to =tab-width=. I'm not 100% sure how these values affect Emacs
outside of their respective modes, but the EmacsWiki recommends this.

(I guess it's possible that other modes may have built off of these
values, to the point where they aren't mode-specific anymore, despite
their naming.)

#+begin_src emacs-lisp
(defvaralias 'c-basic-offset 'tab-width)
(defvaralias 'cperl-indent-level 'tab-width)
#+end_src

[[http://stackoverflow.com/questions/69934/set-4-space-indent-in-emacs-in-text-mode][Tabstops]]

#+begin_src emacs-lisp
(defun my-generate-tab-stops (&optional width max)
  "Return a sequence suitable for `tab-stop-list'."
  (let* ((max-column (or max 200))
         (tab-width (or width tab-width))
         (count (/ max-column tab-width)))
    (number-sequence tab-width (* tab-width count) tab-width)))

(setq tab-stop-list (my-generate-tab-stops))
#+end_src

I'm not entirely sure on this guy. I probably grabbed it from
someone's config. There are a couple of different Python modes, so I'm
not sure if this would affect both of them, or just one of them.

*TODO* Figure this out.

*TODO* Group this with other Python-specific config.

#+begin_src emacs-lisp
(setq-default py-indent-offset 4)
#+end_src

*TODO* Add code to set tabstops here

** Trailing Newline

#+begin_src emacs-lisp
;; Always add a newline at the end of the file
(setq require-final-newline t)
#+end_src

** Encoding

#+begin_src emacs-lisp
  (set-language-environment "UTF-8")
  (set-terminal-coding-system 'utf-8)
  (set-keyboard-coding-system 'utf-8)
  (prefer-coding-system 'utf-8)
#+end_src

** Color Identifiers Mode

[[https://github.com/ankurdave/color-identifiers-mode][=color-identifiers-mode=]] brings some color to identifier names.

#+begin_src emacs-lisp
  (use-package color-identifiers-mode
    :diminish color-identifiers-mode
    :commands color-identifiers-mode
    :defer 1)
#+end_src

* Display Settings

A number of the default settings should just be disabled as they
tend to get in the way.

#+begin_src emacs-lisp
  (setq inhibit-startup-message t)
  (setq initial-scratch-message nil)
  (setq visible-bell t)

  ;; Disable the menu if we're on the console.
  (unless (window-system)
    (when (fboundp 'menu-bar-mode)
      (menu-bar-mode -1)))

  ;; When we're in GUI mode, disable toolbars and scrollbars.
  (when (window-system)
    (when (fboundp 'tool-bar-mode)
      (tool-bar-mode -1))

    (when (fboundp 'horizontal-scroll-bar-mode)
      (horizontal-scroll-bar-mode -1))

    (when (fboundp 'scroll-bar-mode)
      (scroll-bar-mode -1)))

  ;; Make sure that everyone reading the window title knows: THIS! IS! EMACS!
  (setq frame-title-format "%b - Emacs")
  (setq icon-title-format "%b - Emacs")

  ;; Don't pull up a GUI-native file selector. Use the minibuffer. Ths
  ;; only way that FSM intended.
  (setq use-file-dialog nil)

  ;; Default to 'truncating' display of long lines rather than
  ;; wrapping them.
  ;(setq-default truncate-lines t)
#+end_src

** Frame Defaults

Let's also make the initial window ("frame") a little bigger:

#+begin_src emacs-lisp
  (add-to-list 'default-frame-alist '(height . 55))
  (add-to-list 'default-frame-alist '(width . 174))
#+end_src

** Fonts

Set the default font. =ns= is Mac OSX Cocoa / NeXTStep.

#+begin_src emacs-lisp
(when window-system
  (let ((font
         (case window-system
           (ns "Consolas-11") ; MacOSX Cocoa / NeXTStep
           (otherwise "DejaVu Sans Mono-11"))))
    (set-face-attribute 'default nil :font font)))
#+end_src

Old Code:

#+begin_src emacs-lisp :tangle no
;; -!- Old Code -!-
;;
;; (when (eq system-type 'darwin)
;;   ;; default font
;;   (set-face-attribute 'default nil :font "Consolas-11")
;;
;;   ;; use specific font for Korean charset
;;   ;; if you want to use differnt font size for specific charset,
;;   ;; add :size POINT-SIZE in the font-spec
;;   ;(set-fontset-font t 'hangul (font-spec :name "NanumGothicCoding"))
;;   )
#+end_src

** Modeline
*** Cursor Position

Show the line number:

#+begin_src emacs-lisp
;; line number in modeline
(line-number-mode 1)
#+end_src

Show the column number:

#+begin_src emacs-lisp
;; column number in modeline
(column-number-mode 1)
#+end_src

*** Flat Modeline

Make the modeline flat and not [[][Boxy]]. Information gleaned from
[[http://www.reddit.com/r/emacs/comments/23l9oi/flat_modeline/?utm_source=dlvr.it&utm_medium=twitter][this Reddit discussion]].

Note: I've made this into a function because running this prior to
Powerline wasn't having the desired effect. This way I can bind a call
to powerline configuration.

#+begin_src emacs-lisp
  (defun no-boxy-modeline ()
    (set-face-attribute 'mode-line nil :box nil)
    (set-face-attribute 'mode-line-inactive nil :box nil))
  (no-boxy-modeline)
#+end_src

*** Powerline

Turn on powerline for a better modeline... a better
/future/... \*stares into the distance\*.

[[https://github.com/milkypostman/powerline][powerline]] is a port to Emacs of Vim's [[https://github.com/Lokaltog/vim-powerline][vim-powerline]]. This particular
version of powerline is a fork of [[http://www.emacswiki.org/emacs/powerline.el][this original port]]. There are also
[[https://github.com/jonathanchu/emacs-powerline][alternate]] [[https://github.com/Dewdrops/powerline][versions]] of powerline for Emacs.

The history seems to all stem from =powerline.el= that was uploaded to
EmacsWiki. Two versions spawned from that: the [[https://github.com/milkypostman][milkypostman]] version,
and the [[https://github.com/jonathanchu][jonathanchu]] version. There looks to be several forks of the
milkypostman version. There are a couple of smaller forks of the
original =powerline.el= too.


The separator pixmaps have 'off' colurs on OSX + Emacs 24.4. The
following fixes that.

*Explanation*: This looks to be related to the newly enabled sRGB
support (Emacs 24.4 + Mac OSX Cocoa). The separators are supposed to
be generated with the same colors as the adjacent sections, but the
colors turn on only 'almost' there (slightly off-color). Turning off
said support fixes the issue and the separators are generated with
correct colors.

#+begin_src emacs-lisp
  (defun bsandrow/powerline-fix-separator-pixmaps ()
    "The separator pixmaps have 'off' colurs on OSX + Emacs 24.4"
    (when (eq window-system 'ns)
      (setq ns-use-srgb-colorspace nil)))
#+end_src

#+begin_src emacs-lisp
  (use-package powerline
    :config
    (progn
      (bsandrow/powerline-fix-separator-pixmaps)
      (setq powerline-default-separator 'arrow)
      (powerline-evil-theme)

      ;; This seems like the best place to put this. It doesn't seem to
      ;; "stick" unless I call it after the powerline theme is
      ;; initialized.
      (no-boxy-modeline)))
#+end_src

** Fic-Mode

=fic-mode= highlights =FIXME=, =TODO=, etc.

#+begin_src emacs-lisp :tangle no
  (require 'fic-mode)
  (add-hook 'c++-mode-hook 'turn-on-fic-mode)
  (add-hook 'emacs-lisp-mode-hook 'turn-on-fic-mode)
#+end_src

*TODO* Need to work on the appearance of highlighting red-on-yellow
bolded and underlined is a bit garrish.

*Sources:*
- http://www.emacswiki.org/emacs/fic-mode.el
- http://trey-jackson.blogspot.ca/2010/10/emacs-tip-37-fic-modeel.html
** Column Marker Mode

This doesn't work so well. It highlights the character that crosses
the boundary, doesn't show a vertical line indicating where the
boundary is on all lines. (This is what I want.)

#+begin_src emacs-lisp :tangle no
(require 'column-marker)
(add-hook 'emacs-lisp-mode-hook
          (lambda ()
            (interactive)
            (column-marker-1 80)))
#+end_src

** Fill Column Indicator Mode

This does what I want. It displays a line where the fill-column is. As
per the display, it displays a thin line, I personally perfer what
Vim's python-mode does, which is to set the background for the
character position (rectangular block). Maybe I'll configure this
later. Just need to add hooks for the modes where I want this to show
up. Not rocket science... :)

#+begin_src emacs-lisp :tangle no
(require 'fill-column-indicator)
(add-hook 'emacs-lisp-mode-hook 'fci-mode)
#+end_src

** Rainbow Delimiters Mode

=rainbow-delimiters-mode= hightlights delimiter pairs in increasing
depth with different colors. So far I find this useful in Emacs Lisp.

#+begin_src emacs-lisp
  (packages-install '(rainbow-delimiters))
  (use-package rainbow-delimiters
    :commands rainbow-delimiters-mode
    :init (progn
            (add-hook 'emacs-lisp-mode-hook 'rainbow-delimiters-mode)))
#+end_src

** Colors

Install / Configure color themes. :)

#+begin_src emacs-lisp
(packages-install '(solarized-theme
                    base16-theme))

(defun my-add-theme-load-path (path)
  "Add a path to the custom-theme-load-path list."
  (add-to-list 'custom-theme-load-path (file-name-as-directory path)))

(defun my-add-vendor-theme (name)
  "Add a theme path under the vendor/ directory to custom-theme-load-path."
  (my-add-theme-load-path (expand-file-name name vendor-dir)))

(mapc 'my-add-vendor-theme
      '("color-theme-ports"
        "base16-themes"
        "emacs-spacegray-theme"))

;(load-theme 'base16-ocean-dark t)
;(load-theme 'base16-flat-dark t)
;(load-theme 'spacegray t)
(load-theme 'solarized-dark t)
#+end_src

*Resources:*
- http://batsov.com/articles/2012/02/19/color-theming-in-emacs-reloaded/
- http://stackoverflow.com/questions/9900232/changing-color-themes-emacs-24-order-matters
- http://www.emacswiki.org/emacs/?action=browse;oldid=ColorTheme;id=ColorAndCustomThemes
- https://github.com/sellout/emacs-color-theme-solarized/

** Increase / Decrease Font Size

#+begin_src emacs-lisp
  (when (window-system)
    (bind-key "s-+" 'text-scale-increase)
    (bind-key "s--" 'text-scale-decrease))
#+end_src

* Navigation
** ibuffer-mode

=ibuffer-mode= presents a list of all open buffers in Emacs with an
interface to manage those buffers (remove them, group them, switch to
them, etc). It's somewhat analogous to BufferExplorer in Vim, though I
feel like =ibuffer-mode= has more functionality.

#+begin_src emacs-lisp
  ;; Note: I'm not sure how packages-install and use-package will
  ;; interact. packages-install doesn't do anything if the packages
  ;; are already installed, but if it needs to install them, it also
  ;; loads them IIRC. I'm not sure how use-package will handle that.
  (defun my-ibuffer-vc-hook ()
    "Use ibuffer-vc to group by project root."
    (ibuffer-vc-set-filter-groups-by-vc-root)
    (unless (eq ibuffer-sorting-mode 'alphabetic)
      (ibuffer-do-sort-by-alphabetic)))

  (use-package ibuffer
    :ensure ibuffer
    :commands ibuffer-mode
    :defer 1
    :config
    (progn
      (add-hook 'ibuffer-hook 'my-ibuffer-vc-hook)))

  (use-package ibuffer-vc
    :ensure ibuffer-vc
    :commands ibuffer-vc-set-filter-groups-by-vc-root
    :defer 1)
#+end_src

*TODO*: Implement some non-Version Control based groups. There are
examples [[http://emacs-fu.blogspot.ca/2010/02/dealing-with-many-buffers-ibuffer.html][here]], but they conflict with =ibuffer-vc=. (They are both
vying for control over =ibuffer-saved-filter-groups=).

#+begin_src emacs-lisp :tangle no
  (setq ibuffer-saved-filter-groups '(("default"
                                       ("Org" (mode . org-mode)))))
#+end_src

*TODO*: Look into an interface to switch between grouping methods from
insider of =ibuffer-mode=. I would want there to be a special case for
switching to =ibuffer-vc= generated groups. I would also want to use
=ido-mode= completion for the named grouping methods. =ibuffer-vc=
groups would probably be a good default.

*TODO*: Related to 'switching' interface: Maybe a way to cycle through
all of the saved filter groups.

*notes*:

- Implementing group-switching interface doesn't look too difficult. The choices would
  have to be taken from the 'keys' of the =ibuffer-saved-filter-groups= variable, and
  adding in a manual entry for =ibuffer-vc=. =ibuffer-vc= looks like
  it works by calling =ibuffer-vc-generate-filter-groups-by-vc-root=
  to generate a filter group dynamically. So... we would call
  =ibuffer-switch-to-saved-filter-groups= to swtich to one of the
  saved groups or do something like =(setq ibuffer-filter-groups
  (ibuffer-vc-generate-filter-groups-by-vc-root))= if the user chooses
  =ibuffer-vc= (or just call =ibuffer-vc-set-filter-groups-by-vc-root=
  directly).

Some scratch work:

#+begin_src emacs-lisp :tangle no
(setq ibuffer-saved-filter-groups '(("default"
                                     ("Org" (mode . org-mode)))))

(delq nil (mapcar (lambda (x) (and (eq (car x) "default") x)) ibuffer-saved-filter-groups))


(defun tester (filter-group)
  (interactive (list (ido-completing-read
                      "Filter Group: "
                      (append '("ibuffer-vc")
                              (mapcar 'car ibuffer-saved-filter-groups)))))
  (let ((filter-groups (cond
                        ((eq filter-group "ibuffer-vc") (ibuffer-vc-generate-filter-groups-by-vc-root))
                        (t (cdr (filter
                                 (lambda (x) (eq (car x) filter-group))
                                 'ibuffer-saved-filter-groups))))))
    (message "%s" filter-groups)))
  ;; (cond ((eq filter-group "ibuffer-vc") (ibuffer-vc-set-filter-groups-by-vc-root))
  ;;       (t (ibuffer-switch-to-saved-filter-groups filter-group))))

(tester "blah")
#+end_src

** Ido mode

#+begin_src emacs-lisp
    (use-package ido
      :ensure ido
      :config
      (progn
        (ido-mode t)
        (add-hook 'ido-setup-hook 'my-ido-keymap-mods)))
#+end_src

I prefer my matches to be shown vertically (like Vim's [[https://github.com/kien/ctrlp.vim][CtrlP]] or
[[https://bitbucket.org/ns9tks/vim-fuzzyfinder/][FuzzyFinder]]). I use =ido-vertical-mode= to do this. It's the 'best'
solution thus far, but I would prefer if cycling through entries in
the match list moved a cursor rather than rotating the list so that
the match is always the one at the top. I may modify this mode, or
write my own to eventually get what I want.

#+begin_src emacs-lisp
  ;; Display ido-mode matches vertically
  (use-package ido-vertical-mode
    :ensure ido-vertical-mode
    :config (ido-vertical-mode t))
#+end_src

Enable flex matching (via =flx='s =flx-ido=). This is also like CtrlP
and FuzzyFinder. I initially looked into Helm for this, but it seems
like the fuzzy matching is still coming along (currently it only works
in limited instances).

#+begin_src emacs-lisp
  (use-package flx-ido
    :ensure flx-ido
    :init (progn
            (setq ido-enable-flex-matching t)
            (setq ido-user-faces nil))
    :config (flx-ido-mode 1))
#+end_src

Use [[https://github.com/bbatsov/projectile][Projectile]] for in-project searching.

#+begin_src emacs-lisp
  (use-package projectile
    :ensure projectile
    :config (projectile-global-mode))
#+end_src

Let's tie that all together then. If we're in a project, then use
=projectile-find-file=, otherwise we'll use =ido-find-file=. This is
very basic for the time-being, but I'll improve it over time.

#+begin_src emacs-lisp
  (defun my-find-file ()
    "Open file using projectile or ido"
    (interactive)
    (if (projectile-project-p)
        (projectile-find-file)
      (ido-find-file)))
#+end_src

I don't like the default keymap for =ido-mode= completion ui. I would
rather use =C-j= / =C-k= (like Vim's CtrlP) to scroll up and down
through the matches than =C-s= / =C-r=. There modifications are mostly
about reorganizing the keymaps to accomodate this without losing
functionality. I've also mapped out what the changes are in the
comments (e.g. old-binding => new-binding), just for sanity's sake.

#+begin_src emacs-lisp
  (defun my-ido-keymap-mods ()
    "Changes to the default ido-mode keymaps"
    ;; ido-common-completion-map
    ;; -------------------------
    ;; C-j ido-select-text                 => ido-next-match
    ;; C-k kill-line (simple.el)           => ido-prev-match
    ;; C-l recenter-top-bottom (window.el) => ido-select-text
    ;;
    (define-key ido-common-completion-map "\C-j" 'ido-next-match)
    (define-key ido-common-completion-map "\C-k" 'ido-prev-match)
    (define-key ido-common-completion-map "\C-l" 'ido-select-text)

    ;; ido-file-completion-map
    ;; -----------------------
    ;; C-j ido-select-text          => ido-next-match
    ;; C-k ido-delete-file-at-head  => ido-prev-match
    ;; C-l ido-reread-directory     => ido-select-text
    ;; C-r ido-prev-match           => ido-reread-directory
    ;; C-s ido-next-match           => nil
    ;;
    ;; Note: ido-delete-file-at-head reverts to kill-line if the
    ;; cursor is not at the end of the line.
    ;;
    (define-key ido-file-completion-map "\C-j" 'ido-next-match)
    (define-key ido-file-completion-map "\C-k" 'ido-prev-match)
    (define-key ido-file-completion-map "\C-l" 'ido-select-text)
    (define-key ido-file-completion-map "\C-r" 'ido-reread-directory)
    (define-key ido-file-completion-map "\C-s" nil))
#+end_src

Let's get =C-w= working to delete words backwards in =ido-mode=. Well,
at least for file completion as this is my major use of =ido-mode=.

#+begin_src emacs-lisp
;; Fix ido-completion to allow me to use C-w instead of S-M-DEL to
;; delete backward by a word. It's better to use
;; ido-delete-backward-word-updir because it does what I want in this.
;; situation.
;;
(define-key ido-file-completion-map "\C-w" 'ido-delete-backward-word-updir)
#+end_src

** Ace Jump Mode

Load up =ace-jump-mode= for jumping around my buffer. I haven't used
this much yet, but it seems like it could be useful if I ever get
myself into using it more regularly.

#+begin_src emacs-lisp
  (use-package ace-jump-mode
    :commands ace-jump-mode)
#+end_src

The rest of the configuration is in =evil-mode= config right now...

* Organization
** Org-Mode

See [[file:org.org][init-org.el]] for details on my [[http://orgmode.org][Org-Mode]] settings.

#+begin_src emacs-lisp
(org-babel-load-file (expand-file-name "org.org" dotfiles-dir))
#+end_src

** Pomodoro

An [[https://github.com/baudtack/pomodoro.el/blob/master/pomodoro.el][Emacs mode]] for using the [[http://pomodorotechnique.com/][Pomodoro technique]].

#+begin_src emacs-lisp
(setq pomodoro-work-time 25)
(setq pomodoro-short-break 5)
(setq pomodoro-long-break 15)
(setq pomodoro-set-number 4)
#+end_src

Defer loading of =pomodoro= until =pomodoro-start= is called.

#+begin_src emacs-lisp
  (use-package pomodoro
    :commands pomodoro-start
    :defer 1
    :config (pomodoro-add-to-mode-line))
#+end_src

*Sources*:
- [[https://github.com/rodw/.dotfiles/blob/master/emacs/.rods-dot-emacs.org#pomodoro][Where I stumbled across reference to pomodoro.el]]
- [[http://ivan.kanis.fr/pomodoro.el][The original (?) pomodoro.el]]
- [[https://github.com/baudtack/pomodoro.el/blob/master/pomodoro.el][This is the pomodoro.el that I'm currently using]]

* Evil Mode

Make Emacs a little more *evil*...

** evil-leader

=evil-leader-mode= needs to be started prior to =evil-mode= per the
[[https://github.com/cofi/evil-leader#usage][documentation]].

#+begin_src emacs-lisp
  (use-package evil-leader
    :ensure evil-leader
    :config (global-evil-leader-mode))
#+end_src

** Initialize
   
Make sure that =evil-mode= is installed and enabled.

#+begin_src emacs-lisp
  ;; Setup evil-mode >:)
  (use-package evil
    :ensure evil
    :config
    (progn
      (evil-mode 1)))
#+end_src

** evil-surround

[[https://github.com/timcharper/evil-surround][evil-surround]] emulates [[https://github.com/tpope/vim-surround][Tim Pope's vim-surround]].

#+begin_src emacs-lisp
  (use-package evil-surround
    :ensure evil-surround
    :config (global-evil-surround-mode 1))
#+end_src

** Evil Ex Commands

Emulate Vim's =:sort= command:

#+begin_src emacs-lisp
;; I'm used to using :sort all of the time in Vim, so let's alias
;; :sort to :sort-lines for convenience. Huzzah!
(evil-ex-define-cmd "sort" 'sort-lines)
#+end_src

Emulate Vim's =:set wrap= and =:set nowrap=:

#+begin_src emacs-lisp
;; Quickly enable/disable line wrapping
(evil-ex-define-cmd "wrap" 'my-wrap-lines)
(evil-ex-define-cmd "nowrap" (lambda () (setq truncate-lines t)))
#+end_src

** Evil Leader Configuration

Set the =<Leader>=:

#+begin_src emacs-lisp
(evil-leader/set-leader ",")
#+end_src

We don't want to lose the functionality of =<,>=
(=evil-repeat-find-char-reverse=). Due to using =<,>= as the =<Leader>=.

#+begin_src emacs-lisp
(evil-leader/set-key "," 'evil-repeat-find-char-reverse)
#+end_src

Create a generic binding for removing trailing whitespace:

#+begin_src emacs-lisp
;; mneumonic: Remove Whitespace
(evil-leader/set-key "rw" 'delete-trailing-whitespace)
#+end_src

My natural tendency for buffer switching is to hit =<,be>= which I have
bound to [[http://www.vim.org/scripts/script.php?script_id=42][BufferExplorer]] in Vim. The functionality of =switch-to-buffer=
isn't the same, but the general idea that I automatically hit =<,be>=
when I want to switch a buffer remains.

That said, =switch-to-buffer= (with =ido-mode=) is probably better
than BufferExplorer, though the ability to see a _complete_ list of
all buffers is missing.

*NOTE*: Using =ibuffer-mode= instead.

#+begin_src emacs-lisp
;(evil-leader/set-key "be" 'switch-to-buffer)
(evil-leader/set-key "be" 'ibuffer)
#+end_src

Other bindings:

*TODO* Break these up with some explanation

#+begin_src emacs-lisp
;; Having a M-x binding that allows for some auto-completion is always
;; good. I can just use evil-ex-mode for the times when I don't care
;; about auto-completion.
(require 'helm-config)
(evil-leader/set-key "xm" 'helm-M-x)

(evil-leader/set-key
  "d" 'dired-jump ; open current dir in dired-mode
  "k" 'ido-kill-buffer ; kill buffer
  "u" 'undo-tree-visualize ; show the undo-tree
  "f" 'ack ; use ack to search through files

  ;; -- eval bindings --
  "ee" 'eval-last-sexp
  "er" 'eval-region
  "ef" 'eval-defun

  ;; -- ace jump mode --
  "jl" 'ace-jump-line-mode
  "jw" 'ace-jump-word-mode
  "jc" 'ace-jump-char-mode)
#+end_src

** Evil Global Keybindings

Bind =C-p= to =my-find-file= so that we can get =CtrlP=-like
functionality, just like in Vim!

#+begin_src emacs-lisp
;; Nothing emulates Vim's CtrlP plugin yet, but binding file-file to
;; C-p will help me with my muscle memory. I may just need to wrap
;; find-file with something that acts more CtrlP-like when I'm in a
;; repository, otherwise it will just do the regular find-file (with
;; ido-mode).
;(define-key evil-normal-state-map "\C-p" 'ido-find-file)
(define-key evil-normal-state-map "\C-p" 'my-find-file)
#+end_src

Vim uses =C-6= to "switch to previous buffer". This allows one to keep
hitting =C-6= to switch back and forth between two
buffers. =evil-mode= doesn't implement this, so we need to implement
this ourselves:

#+begin_src emacs-lisp
;; use C-6 to swap to a previous buffer
(define-key evil-normal-state-map (kbd "C-6") 'evil-buffer)
#+end_src

** The =Escape= Key

Make the =escape= key cancel all the things.

Sources:
- https://github.com/davvil/.emacs.d/blob/64367f2/init.el#L19

#+begin_src emacs-lisp
;;
;; The Escape Key: Make it cancel everything...
;;
(defun minibuffer-keyboard-quit ()
  "Abort recursive edit.
In Delete Selection mode, if the mark is active, just deactivate it;
then it takes a second \\[keyboard-quit] to abort the minibuffer."
  (interactive)
  (if (and delete-selection-mode transient-mark-mode mark-active)
      (setq deactivate-mark  t)
    (when (get-buffer "*Completions*") (delete-windows-on "*Completions*"))
    (abort-recursive-edit)))

(define-key evil-normal-state-map [escape] 'keyboard-quit)
(define-key evil-visual-state-map [escape] 'keyboard-quit)
(define-key minibuffer-local-map [escape] 'minibuffer-keyboard-quit)
(define-key minibuffer-local-ns-map [escape] 'minibuffer-keyboard-quit)
(define-key minibuffer-local-completion-map [escape] 'minibuffer-keyboard-quit)
(define-key minibuffer-local-must-match-map [escape] 'minibuffer-keyboard-quit)
(define-key minibuffer-local-isearch-map [escape] 'minibuffer-keyboard-quit)
#+end_src

** The Minibuffer

Bind =C-w= to =evil-delete-backward-word= in the minibuffer... because
it just makes sense (to me).

#+begin_src emacs-lisp
;;
;; Get C-w in the minibuffer.
;;
(define-key minibuffer-local-map "\C-w" 'evil-delete-backward-word)
(define-key minibuffer-local-ns-map "\C-w" 'evil-delete-backward-word)
(define-key minibuffer-local-completion-map "\C-w" 'evil-delete-backward-word)
(define-key minibuffer-local-must-match-map "\C-w" 'evil-delete-backward-word)
(define-key minibuffer-local-isearch-map "\C-w" 'evil-delete-backward-word)
#+end_src

** Replace =vim-commentary=

[[https://github.com/tpope/vim-commentary][=vim-commentary=]] is a plugin by [[https://github.com/tpope][Tim Pope]] that I have been happy with
on Vim. Here is where I attempt to get similar behaviour on Emacs.

Note: There is also an [[https://github.com/redguardtoo/evil-nerd-commenter][Emacs port]] of Vim's [[https://github.com/scrooloose/nerdcommenter][NerdCommenter]].

#+begin_src emacs-lisp
(defun my-evil-comment-dwim ()
  (interactive)
  "Like 'comment-dwim', but switches to Insert state when inserting a comment and not operating on a region."
  (unless (and mark-active transient-mark-mode)
    (unless (evil-insert-state-p)
  (evil-insert-state)))
  (call-interactively #'comment-dwim))

(define-key evil-normal-state-map (kbd "gc") #'my-evil-comment-dwim)
#+end_src

*TODO* The =gcu= binding is missing. The current solutions I've look
at in Emacs either operate on a single line, or a visual selection. In
=vim-commentary=, the =gcu= binding attempts to figure out a comment
block that the cursor is in the middle of, then uncomments the entire
block. This isn't super-duper important functionality, but I like
it. I may have to implement this myself though.

** Integrate =evil-mode= and =ibuffer-mode=

Configure =evil-mode= and =ibuffer-mode= to work together.

#+begin_src emacs-lisp
  ;; Start ibuffer-mode out in 'normal' state
  (evil-set-initial-state 'ibuffer-mode 'normal)

  (after 'ibuffer
    ;; use the standard ibuffer bindings as a base
    (set-keymap-parent
     (evil-get-auxiliary-keymap ibuffer-mode-map 'normal t)
     (assq-delete-all 'menu-bar (copy-keymap ibuffer-mode-map)))

    ;; Add in our own bindings
    (evil-define-key 'normal ibuffer-mode-map "j" 'ibuffer-forward-line)
    (evil-define-key 'normal ibuffer-mode-map "k" 'ibuffer-backward-line)
    (evil-define-key 'normal ibuffer-mode-map "/" 'evil-search-forward)
    (evil-define-key 'normal ibuffer-mode-map "n" 'evil-search-next)
    (evil-define-key 'normal ibuffer-mode-map "N" 'evil-search-previous)
    (evil-define-key 'normal ibuffer-mode-map "?" 'evil-search-backward)

    ;; this is bound to "j" by default
    (evil-define-key 'normal ibuffer-mode-map "J" 'ibuffer-jump-to-buffer))

#+end_src

** =org-mode=

Configure =evil-mode= and =org-mode= to work together:

#+begin_src emacs-lisp
;; org-mode Mappings
;; =================
;;
;; Note: I don't like these bindings, but I'll deal with them. My
;; preferred bindings would be:
;;
;;  zo => Open the fold at the current level. All sublevels of folds
;;        retain their state. The body counts as part of the current
;;        fold instead of this weird idea that show-children keeps
;;        the body hidden whole showing immediate sub-headings.
;;
;;  zO => Does what show-subtree does right now. Opens all folds
;;        from the current level downwards.
;;
;;  zC => Works like hide-subtree right now.
;;
;;  zc => Hide at the current level. All sub-levels retain their
;;        state (i.e. if I hit 'zo' to show the fold again, all
;;        sub-levels remember what expanded/collapsed state they are
;;        in.
;;
;; zR => Open all folds (e.g. show-all)
;;
;; zM => Close all folds (e.g. hide-all)
;;
;; zj => Move downwards to the next fold. (downwards in relation to
;;       the file, not the fold level)
;;
;; zk => Move upwards to the next fold. (upwards in relation to the
;;       file, not the fold level)

(evil-leader/set-key-for-mode 'org-mode "le" 'org-insert-link)
(evil-leader/set-key-for-mode 'orgstruct-mode "le" 'org-insert-link)

(evil-define-key 'normal org-mode-map
  (kbd "RET") 'org-open-at-point
  "za"        'org-cycle
  "zA"        'org-shifttab
  "zm"        'hide-body
  "zr"        'show-all
  "zo"        'show-subtree
  "zO"        'show-all
  "zc"        'hide-subtree
  "zC"        'hide-all
  )

(evil-define-key 'normal orgstruct-mode-map
  (kbd "RET") 'org-open-at-point
  "za"        'org-cycle
  "zA"        'org-shifttab
  "zm"        'hide-body
  "zr"        'show-all
  "zo"        'show-subtree
  "zO"        'show-all
  "zc"        'hide-subtree
  "zC"        'hide-all
  )
#+end_src

** Resources

- https://gist.github.com/gcr/3962719
- https://lists.gnu.org/archive/html/emacs-orgmode/2012-02/msg01000.html
- https://github.com/mixandgo/emacs.d/blob/master/my-evil.el
- https://github.com/jubos/dotfiles/blob/master/emacs.d/config/curtis-evil.el
- http://juanjoalvarez.net/es/detail/2014/sep/19/vim-emacsevil-chaotic-migration-guide/

* Coding
** Flycheck

[[https://github.com/flycheck/flycheck][Flycheck]] calls itself "Modern syntax checking for GNU Emacs."

#+begin_src emacs-lisp
  (use-package flycheck
    :ensure flycheck
    :config
    (progn
      (add-hook 'python-mode-hook 'flycheck-mode)
      (add-hook 'scss-mode-hook 'flycheck-mode)
      (add-hook 'emacs-lisp-mode-hook 'flycheck-mode)
      (add-hook 'js2-mode 'flycheck-mode)))
#+end_src

** Python

Use [[https://launchpad.net/python-mode][=python-mode=]] to edit Python code. (By jove! I think he's onto something!)

#+begin_src emacs-lisp
    ;; http://www.emacswiki.org/emacs/ProgrammingWithPythonModeDotEl
    ;; (add-to-list 'load-path (expand-file-name "python-mode.el-6.2.0" vendor-dir))

    (use-package python-mode
      :mode (("\\.py\\'" . python-mode)
             ("\\.wsgi$" . python-mode))
      :interpreter ("python" . python-mode)
      :config
      (progn
        (add-hook 'python-mode-hook 'my-python-mode-prog-mode-fix)
        (add-hook 'python-mode-hook 'my-python-mode-indentation)
        ;; Should I move this to the color-identifiers-mode config?
        (add-hook 'python-mode-hook 'color-identifiers-mode)))
#+end_src

Configure =python-mode='s indentation.

#+begin_src emacs-lisp
  (defun my-python-mode-indentation-config ()
    "Configure python-mode indentation variables"
    ;; 4 spaces for Python. Set this explicitly just to
    ;; make sure. I want all Python files using 4 spaces.
    (setq tab-width 4)
    (setq python-indent tab-width)
    (setq python-indent-offset tab-width)
    (setq py-indent-offset tab-width))
#+end_src

The =python-mode= that comes with Emacs derives from =prog-mode=, but
apparently [[https://launchpad.net/python-mode][the alternate =python-mode=]] that I'm using doens't derive
from =prog-mode= so any =prog-mode-hook='s that I setup won't
activate. We can fix that though. We have the technology...

#+begin_src emacs-lisp
  ;; For some reason python-mode doesn't derive from prog-mode, so they
  ;; prog-mode-hooks don't get run. See more here:
  ;;   https://github.com/flycheck/flycheck/issues/97
  (defun my-python-mode-prog-mode-fix ()
    (run-hooks 'prog-mode-hook))
#+end_src

*TODO* Getting VirtualENVs working
*TODO* Getting VirtualENVs setup if in the correct directory.
*TODO* Get virstualenvs and flycheck-mode working.

** SASS

Use =scss-mode= ([[https://github.com/antonj/scss-mode/][Github]], [[http://www.emacswiki.org/ScssMode][EmacsWiki]]) to handle [[http://sass-lang.com/][Sass]] files. I've turned
off =scss-compile-at-save= because I don't want to compile every time
that I save (especially since it's not using the build processes that
I usually use).

#+begin_src emacs-lisp
  (use-package scss-mode
    :ensure scss-mode
    :defer 1
    :commands scss-mode
    :mode ("\\.scss\\'" . scss-mode)
    :config
    (progn
      (setq scss-compile-at-save nil)))
#+end_src

** JavaScript

Use =js2-mode= for JavaScript. (Note: I should probably break this up
a bit with some explanation.)

Note:
- I grabbed the bit on =js2-auto-indent-p= from [[https://github.com/mooz/js2-mode/issues/9][here]].

#+begin_src emacs-lisp
  (use-package js2-mode
    :defer 1
    :mode ("\\.js\\'" . js2-mode)
    :pre-load (progn
                (setq-default js2-auto-indent-p t))
    :config
    (progn
      (add-hook 'js2-mode-hook 'bs/js2-process-environment)
      ;; (add-hook 'js2-mode-hook 'bs/nodejs-modules-check)
      (add-hook 'js2-mode-hook 'bs/turn-on-flycheck-mode-js2)

      ;; Replace 'function' with 'ƒ'
      (font-lock-add-keywords
       'js2-mode
       `(("\\(function *\\)("
          (0 (progn (compose-region (match-beginning 1) (match-end 1) "ƒ") nil)))))

      ;; Highlight these keywords
      (font-lock-add-keywords
       'js2-mode
       '(("\\<\\(FIX\\|TODO\\|FIXME\\|HACK\\|REFACTOR\\|XXX\\):"
          1 font-lock-warning-face t)))))
#+end_src

Configure indentation controls:

#+begin_src emacs-lisp
  (setq js-basic-indent 2)
  (setq-default js2-basic-indent 2)
  (setq-default js2-basic-offset 2)
  (setq-default js2-enter-indents-newline t)
  (setq-default js2-indent-on-enter-key t)
  ;(setq-default js2-mode-indent-ignore-first-tab t)
#+end_src

Clean up whitespace sometimes:

#+begin_src emacs-lisp
  (setq-default js2-cleanup-whitespace t)
#+end_src

Control over errors:

#+begin_src emacs-lisp

  ;; Let flymake do the error-parsing
  (setq-default js2-show-parse-errors nil)

  (setq-default js2-global-externs
                '("assert" "refute" "setTimeout" "clearTimeout"
                  "setInterval" "clearInterval" "console" "JSON"
                  "jQuery" "$" "angular" "Ember" "module" "require"
                  "process"))

  ;; TODO What does this do:
  (setq js2-mode-toggle-warnings-and-errors t)
#+end_src

Node.js local modules

#+begin_src emacs-lisp
  ;; (defun bs/nodejs-modules-check ()
  ;;   "Add local node_modules directory to $PATH & exec-path"
  ;;   (if (projectile-project-p)
  ;;       (let ((node-modules (expand-file-name
  ;;                            ".bin" (expand-file-name
  ;;                                    "node_modules" (projectile-project-root)))))
  ;;         (if (file-accessible-directory-p node-modules)
  ;;             (append-to-exec-path node-modules)))
  ;;     (let ((cwd (file-name-directory
  ;;                 (or (buffer-file-name) load-file-name)))
  ;;           (node-modules (expand-file-name
  ;;                          ".bin" (expand-file-name
  ;;                                  "node_modules" cwd))))
  ;;       (if (file-accessible-directory-p node-modules)
  ;;           (append-to-exec-path node-modules)))))
#+end_src

*** Local process-environment

#+begin_src emacs-lisp
  (defun bs/js2-process-environment ()
    (make-local-variable 'process-environment))
#+end_src

*** js2-mode + flycheck-mode

#+begin_src emacs-lisp
  (defun bs/turn-on-flycheck-mode-js2 ()
    "Turn on and define JS2 mode checker"
    ;(flycheck-select-checker 'javascript-jslist-reporter)
    (flycheck-select-checker 'javascript-jshint)
    (flycheck-mode 1))
#+end_src

*** nvm.el

Use nvm.el to globally setup NVM environment.

#+begin_src emacs-lisp
  (use-package nvm
    :ensure nvm
    :config
    (progn
      (nvm-use "v0.10.21")
      (append-to-exec-path "/Users/bjs/.nvm/v0.10.21/bin")))
#+end_src

* Text Editing
** Markdown

Use =markdown-mode= to edit Markdown files.

#+begin_src emacs-lisp
  (use-package markdown-mode
    :commands markdown-mode
    :mode (("\\.markdown\\'" . markdown-mode)
           ("\\.mkd\\'" . markdown-mode)
           ;("\\.text\\'" . markdown-mode)
           ("\\.md\\'" . markdown-mode)))
#+end_src
* Work Stuff

#+begin_src emacs-lisp
  (defun sowingo-js2-setup ()
    "Setup js2-mode for Sowingo projects."
    (when (and (projectile-project-p)
               (string/starts-with (expand-file-name (projectile-project-root))
                                   (expand-file-name "~/work/sowingo")))
      (message "Sowingo Project: %s" (expand-file-name (projectile-project-root)))
      ))
#+end_src

* Advanced Stuff
** Edit With Emacs

Edit with Emacs is a Chrome extension that allows you to edit text
from Chrome in Emacs, and then save it back to Chrome. It pairs with a
server to communicate with. In this case, I have setup the elisp
server so that everything is running right in emacs. IIRC, there is
also a Python server implemented that would just call =emacs= or
=emacs-client= and act as a middle-man.

Links:
- [[https://chrome.google.com/webstore/detail/edit-with-emacs/ljobjlafonikaiipfkggjbhkghgicgoh?hl=en][Chrome Store]]
- [[http://www.emacswiki.org/emacs/Edit_with_Emacs][Emacs Wiki]]
- [[https://github.com/stsquad/emacs_chrome][Github]]

Config:
#+begin_src emacs-lisp
  (use-package edit-server
    :init (progn
            ;; Launch the buffer in a new frame, I don't want it to pop
            ;; up in the middle of a frame that I'm already doing
            ;; something in.
            (setq edit-server-new-frame t)
            (edit-server-start)))
#+end_src

** Animated Welcome Message

An animated welcome message. It's pretty nifty, but it doesn't always
do a good job on startup. Also, I don't know where the =cookie=
function comes from. I wasn't able to find it from the original
source (someone's =.emacs.d= on [[https://github.com][Github]]).

#+begin_src emacs-lisp :tangle no
  ; Animated Welcome Message
  (defconst animate-n-steps 4)
  (defun emacs-reloaded () "animated welcome message" (interactive)
    (animate-string
      (concat ";; Initialization successful, welcome to "
              (substring (emacs-version) 0 16)
              "."
              "\n"
              ; ";; Tip of the Day:\n;;   "
              ; "\n"
              ; (cookie "~/.emacs.d/tip-of-the-day.fortune" "s" "e")
              "\n"
              ";; type C-x C-e for more tips\n"
              "(emacs-reloaded)"
              "\n")
      0 0)
    (end-of-buffer) (newline-and-indent)
    ;; (newline-and-indent)  (newline-and-indent)
  )
  (add-hook 'after-init-hook (lambda ()
                               (maximize-frame)
                               (emacs-reloaded)))
#+end_src

* The /FUTURE/
  :PROPERTIES:
  :tangle: no
  :END:
** TODO What's the best way to track project root?

Is the best way to just continue using Projectile? I mainly started
using Projectile for 'find in project' functionality. Is there a
better way of finding the project root for the purposes of building
functionality on?

For example, I have a hook that adds "$DIR/node_modules/.bin" to $PATH
and exec-path as a js2-mode hook. I want "$DIR" to be the project
root, if there is one, otherwise I want it to be the current
directory.

Should I just continue to build this functionality off of Projectile?
I'm just wondering if there is a more 'focused' or 'standard' way of
doing it, so that I don't have to change all of this functionality if
I decide that I don't want to use Projectile for project-based
find-file?

There is [[http://solovyov.net/project-root/][project-root.el]] that looks fairly simple...

** TODO electric-indent-mode?

http://emacsredux.com/blog/2014/01/19/a-peek-at-emacs-24-dot-4-auto-indentation-by-default/

** TODO Why aren't Evil Ex commands working
** TODO Tweak scroll accelerate settings

 Tweak the scroll accelerate setting. I think that I want to
 accelerate scrolling, but before it was /way/ too sensitive.

SOURCE: http://stackoverflow.com/questions/8967919/how-to-define-faster-scrolling-than-triple-wheel-down-in-emacs

#+begin_quote
It seems as if Emacs does not handle scroll events like OSX does. The
double- and triple- modifiers and the event-click-count function
Stefan mentioned do not signify single events of fast scrolling but
merely that several scroll events happend in close succession. So when
you begin to scroll, you get a 'click count' of 1, then 2, then 3 and
so on.

On OSX, the trackpad does not issue individual scroll events like a
mouse-wheel does. Instead, each event contains a pixel increment of
how far the cursor moved since the last event. Programs should move
their scroll-views by a distance proportional to that
increment. However, to my knowledge Emacs scroll events do not contain
that increment. Therefore, Emacs in its current form can not implement
inertial scrolling.

PLEASE correct me if I'm wrong!
#+end_quote

SOURCE: https://lists.gnu.org/archive/html/emacs-devel/2014-01/msg01972.html

#+begin_quote
For what it's worth, I was suffering from exactly the same thing and
eventually unbound the mwheel stuff altogether and simply rebound them
to the following. After that, scrolling was sane again.

(defun scroll-up-one ()
  (interactive)
  (scroll-up 1))

(defun scroll-down-one ()
  (interactive)
  (scroll-down 1))

(defun scroll-up-double-speed ()
  (interactive)
  (scroll-up 3))

(defun scroll-down-double-speed ()
  (interactive)
  (scroll-down 3))

(global-set-key (kbd "<mouse-4>") 'scroll-down-one)
(global-set-key (kbd "<mouse-5>") 'scroll-up-one)
(global-set-key (kbd "<double-mouse-4>") 'scroll-down-double-speed)
(global-set-key (kbd "<double-mouse-5>") 'scroll-up-double-speed)
(global-set-key (kbd "<wheel-up>") 'scroll-down-one)
(global-set-key (kbd "<wheel-down>") 'scroll-up-one)
(global-set-key (kbd "<double-wheel-up>") 'scroll-down-double-speed)
(global-set-key (kbd "<double-wheel-down>") 'scroll-up-double-speed)

Regards,
Elias
#+end_quote

QUOTE: https://lists.gnu.org/archive/html/emacs-devel/2014-01/msg01986.html

#+begin_quote
> For what it's worth, I was suffering from exactly the same thing and
> eventually unbound the mwheel stuff altogether and simply rebound them to
> the following. After that, scrolling was sane again.

You can probably get the same kind of result by tweaking
mouse-wheel-scroll-amount as in:

  (setf (car mouse-wheel-scroll-amount) 1)

But this "shouldn't" be needed.  IOW we should try and figure out why
you get so many scroll events even for short moves.


        Stefan
#+end_quote

** TODO Figure out what this does:

#+begin_example
  (setq js2-mode-toggle-warnings-and-errors t)
#+end_example

** TODO nvm + Emacs

Looks like there is [[https://github.com/rejeep/nvm.el][nvm.el]], but I also see [[https://github.com/jimeh/.emacs.d/blob/master/env.el][hardcoded paths in Emacs
configs]]. =nvm.el= does /not/ seem to touch =exec-path= it only sets
environment variables. I guess this is useful for launching shells in
subprocesses (e.g. =eshell=), but it doesn't really help in the case
of things like =executable-find=.

What do I really want this to do?

1. Subprocesses should find executables in the =nvm= path. I should be able to (e.g.) run =grunt= and not need to installed it to =/usr/local/bin=.
2. Flycheck should find =jshint= in the =nvm= path.

The main things here that I care about are running =grunt= and =jshint= (via Flycheck) from within Emacs.

--

The lack of =exec-path= handling in =nvm.el= puts it at odds with
=flycheck-mode= finding jshint.

--

[[http://stackoverflow.com/questions/16786831/how-can-i-set-environment-variables-to-a-buffer-local-scope-in-emacs][Making environment variables buffer-local]]:

You can do this by making =process-environment= buffer-local:

#+begin_src emacs-lisp :tangle no
(defun setup-some-mode-env ()
  (make-local-variable 'process-environment)
  ;; inspect buffer-file-name and add stuff to process-environment as necessary
  ...)
(add-hook 'some-major-mode 'setup-some-mode-env)
#+end_src

A more elaborate example is this code that imports the Guile
environment setup created by an external script. The script is
designed to be "sourced" in the shell, but here its result gets
imported into a single Emacs buffer:

#+begin_src emacs-lisp :tangle no
(defun my-guile-setup ()
  (make-local-variable 'process-environment)
  (with-temp-buffer
    (call-process "bash" nil t nil "-c"
          "source ~/work/guileenv; env | egrep 'GUILE|LD_LIBRARY_PATH'")
    (goto-char (point-min))
    (while (not (eobp))
      (setq process-environment
        (cons (buffer-substring (point) (line-end-position))
          process-environment))
      (forward-line 1))))

(add-hook 'guile-hook 'my-guile-setup)
#+end_src

Need to set jshintrc in the hook maybe?

** TODO powerline

powerline: https://github.com/milkypostman/powerline
powerline-evil: https://github.com/raugturi/powerline-evil
smart-mode-line: https://github.com/Bruce-Connor/smart-mode-line

** TODO Look into [[https://github.com/flycheck/flycheck][flycheck]] ([[http://www.emacswiki.org/emacs/Flycheck][emacswiki]]).

Also: [[http://www.flycheck.org/en/latest/guide/languages.html#javascript][How to configure a particular JavaScript backend?]]

- How to get flycheck to interface with virtualenv to find flake8?

** TODO Keep on Pimpin' That Config

Resources:
- [ ] [[https://github.com/rpdillon/emacs-config/blob/master/.gitmodules][rpdillon's emacs config]]
- [ ] [[https://github.com/magnars/.emacs.d/blob/master/setup-js2-mode.el][magnars emacs config]]
- [ ] [[https://github.com/howardabrams/dot-files/tree/13fe16a2da8ee269de14b2baadd71580e21926f0][howard abrams emacs config]]
- [ ] [[https://github.com/zk-phi/phi-grep][phi-grep]]
- [ ] [[http://masteringemacs.org/my-emacs-packages][Mastering Emacs Packages]]

** Literate Programming + Emacs Config

- [[http://sachachua.com/blog/2012/06/literate-programming-emacs-configuration-file/][Sacha Chua: Literate programming and my Emacs configuration file]]
- [[https://github.com/jonnay/emagicians-starter-kit/blob/master/Emagician-Install.org][Emagician Starter Kit]] -- A NiH version of the Emacs Starter Kit.
- [[https://github.com/sachac/.emacs.d/blob/gh-pages/Sacha.org#history][Sacha Chua's Emacs Config]]

** TODO Learn Emacs Lisp

Resources:
- [[https://www.gnu.org/software/emacs/manual/html_mono/eintr.html][An Introduction to Programming in Emacs Lisp]]
- [[http://stackoverflow.com/questions/1664202/emacs-lisp-evaluate-variable-in-alist][Stack Overflow: How to Eval a Variable in an alist]]
- [[http://stackoverflow.com/questions/15485833/emacs-lisp-evaluate-variable-in-alist][Stack Overflow: Emacs lisp evaluate variable in alist]]

** Reading List

- [ ] [[http://www.howardism.org/Technical/Emacs/literate-devops.html][Literate DevOps]]
- [ ] [[http://uncommonlisp.blogspot.ca/2013/01/emacs-vs-vim-part-2.html][Uncommon Lisp]]
- [ ] [[https://news.ycombinator.com/item?id=8709996][Emacs Isn't For Everyone]]

** TODO evil-tabs + elscreen

https://github.com/krisajenkins/evil-tabs

** TODO Read up on Cask

https://github.com/cask/cask

** DONE Fix powerline Separator Weirdness

[[http://emacsredux.com/blog/2014/01/11/a-peek-at-emacs-24-dot-4-srgb-colours-on-os-x/][this]] seems to solve it. It has something to
do with sRGB colourspace.

** DONE Convert over to =after= macro

Go through everything and convert it over to using the =after= macro.

** DONE ido-vertical-mode scrolling

Looks like there is no 'easy' way to do this. ido-vertical-mode is a
thin wrapper around ido-mode that changes the display template to
includes things like newlines. There is no quick/easy way to do what I
want to do here.

I looked through the package source, and this is what I found.

* Misc. Sources

Some sources of config/inspiration that I've tapped in the past:

- https://github.com/drewfrank/dotfiles/blob/master/.emacs
- http://www.emacswiki.org/Evil
- http://changelog.complete.org/archives/661-so-long-vim-im-returning-to-emacs
- http://juanjoalvarez.net/es/detail/2014/sep/19/vim-emacsevil-chaotic-migration-guide/
- http://whattheemacsd.com/init.el-04.html (diminish-mode post)
- http://hbin.me/blog/2012/08/26/clean-the-emacs-mode-line/ (clean up the emacs mode line)
- [[http://raebear.net/comp/emacscolors.html][Colors Available to Emacs]]
